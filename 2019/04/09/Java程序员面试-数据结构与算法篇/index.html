<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java程序员-数据结构与算法篇 | 阿鱼的碎碎念</title><meta name="description" content="欲练此功，必先头秃。 ## 1.链表  1.链表的增删操作链表的储存特点：可以用任意一组存储单元来存储单链表中的数据元素（存储单元可以是不连续的）  ，而且，除了存储每个数据元素的值以外，还必须存储指示其直接后继元素的信息。这两部分信息组成的数据元素的存储映像称为结点。N个结点链在一块被称为链表，当结点只包含其后继结点的信息的链表就被称为单链表。java中可以如下定义来存储节点信息： class"><meta name="keywords" content="面试,数据结构"><meta name="author" content="鱼歌唱晚"><meta name="copyright" content="鱼歌唱晚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://x2yu.com/2019/04/09/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AF%87/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java程序员-数据结构与算法篇"><meta property="og:url" content="http://x2yu.com/2019/04/09/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AF%87/"><meta property="og:site_name" content="阿鱼的碎碎念"><meta property="og:description" content="欲练此功，必先头秃。 ## 1.链表  1.链表的增删操作链表的储存特点：可以用任意一组存储单元来存储单链表中的数据元素（存储单元可以是不连续的）  ，而且，除了存储每个数据元素的值以外，还必须存储指示其直接后继元素的信息。这两部分信息组成的数据元素的存储映像称为结点。N个结点链在一块被称为链表，当结点只包含其后继结点的信息的链表就被称为单链表。java中可以如下定义来存储节点信息： class"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-04-09T07:32:31.000Z"><meta property="article:modified_time" content="2020-07-17T02:50:55.031Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="数据库练习题" href="http://x2yu.com/2019/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98/"><link rel="next" title="Java程序员-设计模式篇" href="http://x2yu.com/2019/04/06/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#欲练此功，必先头秃。"><span class="toc-number">1.</span> <span class="toc-text">欲练此功，必先头秃。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-链表的增删操作"><span class="toc-number">2.</span> <span class="toc-text">1.链表的增删操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-从链表中删除重复数据"><span class="toc-number">3.</span> <span class="toc-text">1.2 从链表中删除重复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3找出单链表中的倒数K个元素"><span class="toc-number">4.</span> <span class="toc-text">1.3找出单链表中的倒数K个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-实现链表的反转"><span class="toc-number">5.</span> <span class="toc-text">1.4 实现链表的反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-倒序输出单链表"><span class="toc-number">6.</span> <span class="toc-text">1.5 倒序输出单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-寻找单链表的中间结点"><span class="toc-number">7.</span> <span class="toc-text">1.6 寻找单链表的中间结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-判断链表是否有环"><span class="toc-number">8.</span> <span class="toc-text">1.7 判断链表是否有环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-在不知道头指针的情况下删除指定结点"><span class="toc-number">9.</span> <span class="toc-text">1.8 在不知道头指针的情况下删除指定结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-判断两个链表是否相交"><span class="toc-number">10.</span> <span class="toc-text">1.9 判断两个链表是否相交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-栈和队列"><span class="toc-number"></span> <span class="toc-text">2. 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-栈和队列的基本概念"><span class="toc-number">1.</span> <span class="toc-text">2.1 栈和队列的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-实现栈"><span class="toc-number">2.</span> <span class="toc-text">2.2 实现栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-用O-1-的复杂度求栈中最小元素"><span class="toc-number">3.</span> <span class="toc-text">2.3 用O(1)的复杂度求栈中最小元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-实现队列"><span class="toc-number">4.</span> <span class="toc-text">2.4 实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-两个栈模拟队列操作"><span class="toc-number">5.</span> <span class="toc-text">2.5 两个栈模拟队列操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-排序"><span class="toc-number"></span> <span class="toc-text">3. 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-选择排序"><span class="toc-number">1.</span> <span class="toc-text">3.1 选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-插入排序"><span class="toc-number">2.</span> <span class="toc-text">3.2 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-冒泡排序"><span class="toc-number">3.</span> <span class="toc-text">3.3 冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-归并排序"><span class="toc-number">4.</span> <span class="toc-text">3.4 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-快速排序"><span class="toc-number">5.</span> <span class="toc-text">3.5 快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-位运算"><span class="toc-number"></span> <span class="toc-text">4. 位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-移位操作实现乘法"><span class="toc-number">1.</span> <span class="toc-text">4.1 移位操作实现乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-判断一个数是否为2的n次方"><span class="toc-number">2.</span> <span class="toc-text">4.2 判断一个数是否为2的n次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-二进制数中1的个数"><span class="toc-number">3.</span> <span class="toc-text">4.3 二进制数中1的个数</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">阿鱼的碎碎念</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java程序员-数据结构与算法篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-04-09 15:32:31"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2019-04-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-17 10:50:55"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-17</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">7.4k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 32 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="欲练此功，必先头秃。"><a href="#欲练此功，必先头秃。" class="headerlink" title="欲练此功，必先头秃。"></a><center>欲练此功，必先头秃。</center></h3><center><img src= "/img/loading.gif" data-src="/assets/blogImg/data_structure.jpg" width="50%" height="50%"></center>
## 1.链表

<h3 id="1-链表的增删操作"><a href="#1-链表的增删操作" class="headerlink" title="1.链表的增删操作"></a>1.链表的增删操作</h3><p>链表的储存特点：可以用任意一组存储单元来存储单链表中的数据元素（存储单元可以是不连续的）</p>
<a id="more"></a>
<p>，而且，除了存储每个数据元素的值以外，还必须存储指示其直接后继元素的信息。这两部分信息组成的数据元素的存储映像称为结点。N个结点链在一块被称为链表，当结点只包含其后继结点的信息的链表就被称为单链表。<br>java中可以如下定义来存储节点信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	Node next &#x3D; null;</span><br><span class="line">	int data;</span><br><span class="line">	public Node(int dat) &#123;</span><br><span class="line">		this.data &#x3D; data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表的插入</strong>操作是将值为x的新结点插入到单链表的第i个结点的位置上，即插入到数据元素ai-1与ai之间。其具体步骤如下：</p>
<p>1) 找到ai-1的引用（存储位置）p<br>2) 生成一个数据域为x的新结点s<br>3) 设置 p. next=s<br>4) 设置 s.next  = a</p>
<p><strong>单链表的删除</strong>操作是将单链表的第i个结点删去。</p>
<p>1) 找到ai-1的存储位置p。<br>2) 令p. next指向ai的直接后继结点（即把ai从链上摘下）ai+1</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyLinkedList &#123;</span><br><span class="line">	</span><br><span class="line">	 Node head &#x3D; null;&#x2F;&#x2F;链表头的应引用</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 向链表中插入数据</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	</span><br><span class="line">	public void addNode(int d)&#123;</span><br><span class="line">		Node newNode &#x3D; new Node(d);</span><br><span class="line">		if(head&#x3D;&#x3D;null) &#123;</span><br><span class="line">			head &#x3D; newNode;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		Node tmp &#x3D; head;</span><br><span class="line">		while(tmp.next!&#x3D;null) &#123;</span><br><span class="line">			tmp &#x3D; tmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp.next &#x3D; newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 返回节点的长度</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public int length() &#123;</span><br><span class="line">		int length &#x3D; 0;</span><br><span class="line">		Node tmp &#x3D; head;</span><br><span class="line">		while(tmp!&#x3D;null) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			tmp &#x3D; tmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 删除第index个节点</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public Boolean deleteNode(int index) &#123;</span><br><span class="line">		if(index&lt;1||index&gt;length()) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;删除链表第一个元素</span><br><span class="line">		if(index &#x3D;&#x3D;1) &#123;</span><br><span class="line">			head &#x3D; head.next;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int i &#x3D; 2;</span><br><span class="line">		Node preNode &#x3D; head;</span><br><span class="line">		Node curNode &#x3D; preNode.next;</span><br><span class="line">		while(curNode!&#x3D;null) &#123;</span><br><span class="line">			if(i&#x3D;&#x3D;index) &#123;</span><br><span class="line">				preNode.next &#x3D; curNode.next;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">			preNode &#x3D; curNode;</span><br><span class="line">			curNode &#x3D; curNode.next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 对链表进行排序</span><br><span class="line">	 * 返回排序后的头节点</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public Node orderList() &#123;</span><br><span class="line">		Node nextNode &#x3D; null;</span><br><span class="line">		int temp &#x3D; 0;</span><br><span class="line">		Node curNode &#x3D; head;</span><br><span class="line">		while(curNode.next!&#x3D;null) &#123;</span><br><span class="line">			nextNode &#x3D; curNode.next;</span><br><span class="line">			while(nextNode!&#x3D;null) &#123;</span><br><span class="line">				if(curNode.data&gt;nextNode.data) &#123;</span><br><span class="line">			temp &#x3D; curNode.data;  curNode.data &#x3D; nextNode.data;  nextNode.data &#x3D; temp;  &#125;  nextNode &#x3D; nextNode.next;  &#125;		temp &#x3D; curNode.data;</span><br><span class="line">					curNode.data &#x3D; nextNode.data;</span><br><span class="line">					nextNode.data &#x3D; temp;</span><br><span class="line">				&#125;</span><br><span class="line">				nextNode &#x3D; nextNode.next;</span><br><span class="line">			&#125;</span><br><span class="line">			curNode &#x3D; curNode.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 打印链表</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public void printList() &#123;</span><br><span class="line">		Node tmp &#x3D; head;</span><br><span class="line">		while(tmp!&#x3D;null) &#123;</span><br><span class="line">			System.out.println(tmp.data);</span><br><span class="line">			tmp &#x3D; tmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		MyLinkedList list &#x3D; new MyLinkedList();</span><br><span class="line">		list.addNode(4);</span><br><span class="line">		list.addNode(3);</span><br><span class="line">		list.addNode(9);</span><br><span class="line">		list.addNode(6);</span><br><span class="line">		System.out.println(&quot;链表长度:&quot;+list.length());</span><br><span class="line">		System.out.println(&quot;排序前:&quot;);</span><br><span class="line">		list.printList();</span><br><span class="line">		list.deleteNode(2);</span><br><span class="line">		System.out.println(&quot;删除index&#x3D;2的节点后:&quot;);</span><br><span class="line">		list.printList();</span><br><span class="line">		list.orderList();</span><br><span class="line">		System.out.println(&quot;排序后:&quot;);</span><br><span class="line">		list.printList();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>链表长度:4<br>排序前:<br>4<br>3<br>9<br>6<br>删除index=2的节点后:<br>4<br>3<br>9<br>排序后:<br>3<br>4<br>9</p>
<h3 id="1-2-从链表中删除重复数据"><a href="#1-2-从链表中删除重复数据" class="headerlink" title="1.2 从链表中删除重复数据"></a>1.2 从链表中删除重复数据</h3><p>1）最容易想到的就是遍历链表，把遍历到的值存储到一个Hashtable中，在遍历过程中，若当前访问的值在Hashtable中已经存在，则是重复的，删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * 删除链表中的重复数据</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public void deleteDupecate(Node head) &#123;</span><br><span class="line">		Hashtable&lt;Integer, Integer&gt;table &#x3D; new Hashtable&lt;&gt;();</span><br><span class="line">		Node tmp &#x3D; head;</span><br><span class="line">		Node pre &#x3D; null;</span><br><span class="line">		</span><br><span class="line">		while(tmp!&#x3D;null) &#123;</span><br><span class="line">			if(table.containsKey(tmp.data))&#x2F;&#x2F;判断是否包含指定的键名</span><br><span class="line">				pre.next &#x3D; tmp.next;</span><br><span class="line">			else &#123;</span><br><span class="line">				table.put(tmp.data, 1);</span><br><span class="line">				pre &#x3D; tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			tmp &#x3D; tmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>优点：时间复杂度低，<br>缺点：在遍历过程中需要额外的存储空间来保存已遍历过的值。</p>
<p>2) 为对链表进行双重循环遍历，外循环正常遍历链表，假设外循环当前遍历的结点为cur,内循环从cur开始遍历，若碰到与cur所指向结点值相同，则删除这个重复结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 双重循环遍历删除链表中的重复数据</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public void deleteDupecateDouble(Node node) &#123;</span><br><span class="line">	Node p &#x3D; head;</span><br><span class="line">	while(p!&#x3D;null) &#123;</span><br><span class="line">		Node q &#x3D; p;</span><br><span class="line">		while(q.next!&#x3D;null) &#123;</span><br><span class="line">			if(p.data &#x3D;&#x3D; q.next.data) &#123;</span><br><span class="line">				q.next &#x3D; p.next.next;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				q &#x3D; q.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p &#x3D; p.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：在遍历过程中不需要额外的存储空间来保存已遍历过的值。<br>缺点：时间复杂度高</p>
<h3 id="1-3找出单链表中的倒数K个元素"><a href="#1-3找出单链表中的倒数K个元素" class="headerlink" title="1.3找出单链表中的倒数K个元素"></a>1.3找出单链表中的倒数K个元素</h3><p>如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素后刚好达到链表尾，那么该元素就是要找的倒数第k个<br>元素。<br>设计如下算法：<br>在查找过程中，设置两个指针，让其中一个指针比另一个指针<strong>（Java没有指针概念，但是引用与指针有着非常相似的性质。便于理解，后续都采用指针的概念）</strong>先前移k -1步，然后两个指针同时往前移动。循环直到先行的指针值为NULL时，另一个指针所指的位置就是所要找的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询倒数第K个元素</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public Node findElem(Node head,int k) &#123;</span><br><span class="line">	if(k&lt;1||k&gt;this.length())</span><br><span class="line">		return null;</span><br><span class="line">	Node p1 &#x3D; head;</span><br><span class="line">	Node p2 &#x3D; head;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;&#x3D;k;i++)&#x2F;&#x2F;前移k-1步</span><br><span class="line">		p1 &#x3D; p1.next;</span><br><span class="line">	while(p1!&#x3D;null) &#123;</span><br><span class="line">		p1 &#x3D; p1.next;</span><br><span class="line">		p2 &#x3D; p2.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-实现链表的反转"><a href="#1-4-实现链表的反转" class="headerlink" title="1.4 实现链表的反转"></a>1.4 实现链表的反转</h3><blockquote>
<p>参考：<a href="https://blog.csdn.net/fx677588/article/details/72357389" target="_blank" rel="noopener">链表翻转的图文讲解</a></p>
</blockquote>
<p>正确地反转一个链表，需要调整指针的指向。下面介绍递归和迭代两种方法的实现。<br><strong>链表翻转操作的顺序对于迭代来说是从链头往链尾，而对于递归是从链尾往链头。</strong><br><strong>递归法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * 递归法反转链表</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public Node reverseList(Node node) &#123;</span><br><span class="line">		if(node &#x3D;&#x3D; null || node.next &#x3D;&#x3D;null) &#123;</span><br><span class="line">			return node; </span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			</span><br><span class="line">			Node newHead &#x3D; reverseList(node.next);</span><br><span class="line">			node.next.next &#x3D; node;</span><br><span class="line">			node.next &#x3D; null;</span><br><span class="line">			</span><br><span class="line">			this.head &#x3D; newHead;&#x2F;&#x2F;将新的头节点设置到static head(打印方法决定)</span><br><span class="line">			return newHead;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归法图示：</strong></p>
<ol>
<li><p>一直递归压栈，直到回归条件，<strong>整个过程NewH指针一直指向存放5的地址空间</strong><br><img src= "/img/loading.gif" data-src="/assets/blogImg/digui_1.jpg" alt="digui_1"></p>
</li>
<li><p>H指向的地址赋值给H-&gt;next-&gt;next指针，<strong>并且一定要记得让H-&gt;next =NULL，也就是断开现在指针的链接，否则新的链表形成了环，下一层H-&gt;next-&gt;next赋值的时候会覆盖后续的值。</strong><br><img src= "/img/loading.gif" data-src="/assets/blogImg/digui_2.jpg" alt="digui_2"></p>
</li>
<li><p>直到最后数据结点方向完全改变，返回到头<br><img src= "/img/loading.gif" data-src="/assets/blogImg/digui_3.jpg" alt="digui_3"></p>
</li>
</ol>
<p><strong>遍历法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 遍历法反转链表</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public void reverse(Node head) &#123;</span><br><span class="line">	Node pReversedHead &#x3D; head;&#x2F;&#x2F;存储反转后的头节点</span><br><span class="line">	Node pNode &#x3D;head;</span><br><span class="line">	Node pPrev &#x3D; null;</span><br><span class="line">	while(pNode!&#x3D;null) &#123;</span><br><span class="line">		Node pNext &#x3D; pNode.next;</span><br><span class="line">		if(pNext&#x3D;&#x3D;null)</span><br><span class="line">			pReversedHead &#x3D; pNode;</span><br><span class="line">		</span><br><span class="line">		pNode.next &#x3D; pPrev;</span><br><span class="line">		pPrev &#x3D; pNode;</span><br><span class="line">		pNode &#x3D; pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	this.head &#x3D; pReversedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>遍历图示</strong></p>
<ol>
<li><p>对于链表设置两个指针：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/bianli_1.jpg" alt="bianli_1"></p>
</li>
<li><p><strong>不可以上来立即将上图中P-&gt;next直接指向NewH，这样存放2的地址就会被丢弃，后续链表保存的数据也随之无法访问。应设置一个临时指针tmp，暂时指向P-&gt;next指向的地址空间，保存原链表后续数据。然后再让P-&gt;next指向NewH，最后P=tmp就可以取回原链表的数据了，所有循环访问也可以继续展开下去。</strong><br><img src= "/img/loading.gif" data-src="/assets/blogImg/bianli_2.jpg" alt="bianli_2"></p>
</li>
<li><p>指针继续向后移动，直到P指针指向NULL停止迭代。<br><img src= "/img/loading.gif" data-src="/assets/blogImg/bianli_3.jpg" alt="bianli_3"></p>
</li>
<li><p>最后<br><img src= "/img/loading.gif" data-src="/assets/blogImg/bianli_4.jpg" alt="bianli_4"></p>
</li>
</ol>
<h3 id="1-5-倒序输出单链表"><a href="#1-5-倒序输出单链表" class="headerlink" title="1.5 倒序输出单链表"></a>1.5 倒序输出单链表</h3><p><strong>运用递归</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * 从尾到头输出链表</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public void printReversely(Node head) &#123;</span><br><span class="line">		if(head.next!&#x3D;null) &#123;</span><br><span class="line">			printReversely(head.next);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(head.data);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-寻找单链表的中间结点"><a href="#1-6-寻找单链表的中间结点" class="headerlink" title="1.6 寻找单链表的中间结点"></a>1.6 寻找单链表的中间结点</h3><p>如果是双向链表，可以首尾并行，利用两个指针一个从头到尾遍历，一个从尾到头遍历， 当两个指针相遇时，就找到了中间元素。单链表，也可以采用双指针的方式来实现中间结点的快速查找。</p>
<ol>
<li>有两个指针同时从头开始遍历；</li>
<li>一个快指针一次走两步，一 个慢指针一次走一步；第三步，快指针先到链表尾部，而慢指针则恰好到达链表中部</li>
</ol>
<p><strong>快指针到链表尾部时，当链表长度为奇数时，慢指针指向的即是链表中间指针，当链表长度为偶数时，慢指针指向的结点和慢指针指向结点的下一个结点都是链表的中间结点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * 寻找单链表中间节点</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public Node serachMid(Node head) &#123;</span><br><span class="line">		Node pNode &#x3D; head;&#x2F;&#x2F;走两步的指针</span><br><span class="line">		Node qNode &#x3D; head;&#x2F;&#x2F;走一步最后指向中间节点的指针</span><br><span class="line">		while(pNode !&#x3D; null &amp;&amp; pNode.next !&#x3D; null &amp;&amp; pNode.next.next !&#x3D;null) &#123;</span><br><span class="line">			pNode &#x3D; pNode.next.next;</span><br><span class="line">			qNode &#x3D; qNode.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return qNode;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-判断链表是否有环"><a href="#1-7-判断链表是否有环" class="headerlink" title="1.7 判断链表是否有环"></a>1.7 判断链表是否有环</h3><blockquote>
<p>深入理解：<a href="http://www.cnblogs.com/zhyg6516/archive/2011/03/29/1998831.html" target="_blank" rel="noopener">判断单链表里面有没有环</a></p>
</blockquote>
<p>** 两个指针从链表头部同时出发，一个每次前进一步，另一个每次前进两步，如果有环，它们一定会相遇**</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 检查是否有环</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public boolean isLoop(Node head) &#123;</span><br><span class="line">	Node fast &#x3D; head;</span><br><span class="line">	Node slow &#x3D; head;</span><br><span class="line">	if(fast&#x3D;&#x3D;null) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	while(fast !&#x3D; null &amp;&amp; fast.next!&#x3D;null) &#123;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		if(fast &#x3D;&#x3D; slow) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return !(fast &#x3D;&#x3D; null||fast.next &#x3D;&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-在不知道头指针的情况下删除指定结点"><a href="#1-8-在不知道头指针的情况下删除指定结点" class="headerlink" title="1.8 在不知道头指针的情况下删除指定结点"></a>1.8 在不知道头指针的情况下删除指定结点</h3><p>*<em>两种情况来讨论： *</em><br>① 若待删除的结点为链表尾结点，则无法删除，因为删除后无法使其前驱结点的next指针置为空；<br>② 若待删除的结点不是尾结点，则可以通过交换这个结点与其后继结点的值，然后删除后继结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * 不知道头指针的情况下删除指定结点</span><br><span class="line">	 * *&#x2F;</span><br><span class="line">	public boolean deleteNode(Node node) &#123;</span><br><span class="line">		if(node &#x3D;&#x3D; null || node.next&#x3D;&#x3D;null)</span><br><span class="line">			return false;</span><br><span class="line">		int tmp &#x3D; node.data;</span><br><span class="line">		node.data &#x3D; node.next.data;</span><br><span class="line">		node.next.data &#x3D; tmp;</span><br><span class="line">		node.next &#x3D; node.next.next;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-判断两个链表是否相交"><a href="#1-9-判断两个链表是否相交" class="headerlink" title="1.9 判断两个链表是否相交"></a>1.9 判断两个链表是否相交</h3><blockquote>
<p> 深入了解：<a href="https://www.jianshu.com/p/634c147fe2a9" target="_blank" rel="noopener">JAVA 判断两个单链表是否相交并求交点</a></p>
</blockquote>
<p>如果两个链表相交，那么它们一定<strong>相同的尾结点</strong>，因此实现思路为：分别遍历两个链表，记录它们的尾结点，如果它们的尾结点相同，那么这两个链表相交，否则不相交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断两个链表是否相交</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public boolean isIntersect(Node n1,Node n2) &#123;</span><br><span class="line">	if(n1 &#x3D;&#x3D; null || n2 &#x3D;&#x3D; null)</span><br><span class="line">		return false;</span><br><span class="line">	Node tail1 &#x3D; n1;</span><br><span class="line">	&#x2F;&#x2F;找到n1的尾节点</span><br><span class="line">	while(tail1.next!&#x3D;null) &#123;</span><br><span class="line">		tail1 &#x3D; tail1.next;</span><br><span class="line">	&#125;</span><br><span class="line">	Node tail2 &#x3D; n2;</span><br><span class="line">	&#x2F;&#x2F;找到n2的尾节点</span><br><span class="line">	while(tail2.next!&#x3D;null) &#123;</span><br><span class="line">		tail2 &#x3D; tail2.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return tail1 &#x3D;&#x3D; tail2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2. 栈和队列"></a>2. 栈和队列</h2><h3 id="2-1-栈和队列的基本概念"><a href="#2-1-栈和队列的基本概念" class="headerlink" title="2.1 栈和队列的基本概念"></a>2.1 栈和队列的基本概念</h3><p>栈和队列都是比较常用的数据结构。</p>
<p><strong>栈</strong>就像一个很窄的桶，先存进去的数据只能最后被取出来，是L I F O ( Last In First Out ,后进先出），它将进出顺序逆序，即<strong>先进后出，后进先出</strong>。</p>
<p><strong>队列</strong>则像人们日常排队买东 西的“队列”，先排队的人先买，后排队的人后买，是FIFO (First In First Out,先进先岀） 的，它保持进岀顺序一致，即<strong>先进先出，后进后岀</strong>。</p>
<p><strong>注意区分： 程序的内存分配中的栈区（stack），堆区（heap），全局区（静态区）（static），文字常量区，程序代码区</strong></p>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/yingms/article/details/53188974" target="_blank" rel="noopener">关于堆栈的讲解</a></p>
</blockquote>
<h3 id="2-2-实现栈"><a href="#2-2-实现栈" class="headerlink" title="2.2 实现栈"></a>2.2 实现栈</h3><blockquote>
<p> 扩展：<a href="https://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">JAVA泛型通配符T，E，K，V区别，T以及Class<T>，Class&lt;?&gt;的区别</a><br>可以采用数组和链表两种方法来实现栈。<br><strong>数组实现：</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class MyStack &lt;E&gt;&#123;</span><br><span class="line">	private Object [] stack;</span><br><span class="line">	private int size;&#x2F;&#x2F;数组中储存元素的个数</span><br><span class="line">	public MyStack() &#123;</span><br><span class="line">		stack &#x3D; new Object[10];&#x2F;&#x2F;初始长度为10</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;判断栈是否为空</span><br><span class="line">	public boolean isEmpty() &#123;</span><br><span class="line">		return size &#x3D;&#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public E peek() &#123;</span><br><span class="line">		if(isEmpty()) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return (E)stack[size-1];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;出栈</span><br><span class="line">	public E pop() &#123;</span><br><span class="line">		E e &#x3D; peek();</span><br><span class="line">		stack[size-1] &#x3D; null;</span><br><span class="line">		size--;</span><br><span class="line">		return e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;入栈</span><br><span class="line">	public E Push(E item) &#123;</span><br><span class="line">		ensureCapacity(size+1);</span><br><span class="line">		stack[size++] &#x3D; item;</span><br><span class="line">		return item;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;判断数组容器是否已满，如果满了就扩充</span><br><span class="line">	private void ensureCapacity(int size) &#123;</span><br><span class="line">		int len &#x3D; stack.length;</span><br><span class="line">		if(size&gt;len) &#123;&#x2F;&#x2F;数组满</span><br><span class="line">			int newLen  &#x3D; 10;&#x2F;&#x2F;每次数组扩充的容量</span><br><span class="line">			stack &#x3D; Arrays.copyOf(stack, size+newLen);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		MyStack&lt;Integer&gt;s &#x3D; new MyStack&lt;Integer&gt;();</span><br><span class="line">		s.Push(1);</span><br><span class="line">		s.Push(2);</span><br><span class="line">		System.out.println(&quot;栈中元素个数：&quot;+s.size);</span><br><span class="line">		System.out.println(&quot;栈顶元素为：&quot;+s.peek());</span><br><span class="line">		System.out.println(&quot;出栈元素为：&quot;+s.pop());</span><br><span class="line">		System.out.println(&quot;再次出栈元素为：&quot;+s.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>栈中元素个数：2<br>栈顶元素为：2<br>出栈元素为：2<br>再次出栈元素为：1</p>
<p><strong>链表实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&lt;E&gt;&#123;</span><br><span class="line">	Node&lt;E&gt;next &#x3D; null;</span><br><span class="line">	E data;</span><br><span class="line">	public Node(E data) &#123;</span><br><span class="line">		this.data &#x3D; data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line">	Node&lt;E&gt;top &#x3D; null;</span><br><span class="line">	</span><br><span class="line">	public boolean isEmpty() &#123;</span><br><span class="line">		return top &#x3D;&#x3D; null;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void push(E data) &#123;</span><br><span class="line">			Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(data);</span><br><span class="line">			newNode.next &#x3D; top;</span><br><span class="line">			top &#x3D; newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public E pop() &#123;</span><br><span class="line">		if(this.isEmpty())</span><br><span class="line">			return null;</span><br><span class="line">		E data &#x3D; top.data;</span><br><span class="line">		top &#x3D; top.next</span><br><span class="line">		return data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public E peek() &#123;</span><br><span class="line">		if(isEmpty()) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return top.data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Stack&lt;Integer&gt; s &#x3D; new Stack&lt;&gt;();</span><br><span class="line">		s.push(1);</span><br><span class="line">		s.push(2);</span><br><span class="line">		s.push(3);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;栈顶元素为：&quot;+s.peek());</span><br><span class="line">		System.out.println(&quot;出栈元素：&quot;+s.pop());</span><br><span class="line">		System.out.println(&quot;出栈元素：&quot;+s.pop());</span><br><span class="line">		System.out.println(&quot;出栈元素：&quot;+s.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>栈顶元素为：3<br>出栈元素：3<br>出栈元素：2<br>出栈元素：1</p>
<h3 id="2-3-用O-1-的复杂度求栈中最小元素"><a href="#2-3-用O-1-的复杂度求栈中最小元素" class="headerlink" title="2.3 用O(1)的复杂度求栈中最小元素"></a>2.3 用O(1)的复杂度求栈中最小元素</h3><p>可以用另外一个变量来记录栈底的位置，通过遍历栈中的所有元素找出最小值，但是这种方法的时间复杂度为0(n)。<br>在算法设计中，经常会采用空间来换取时间的方式来提高时间复杂度，也就是说，采用额外的存储空间来降低操作的时间复杂度。</p>
<p><strong>O(1)复杂度具体实现：</strong>使用两个栈结构，一个栈用来存储数据，另一个栈（<strong>辅助栈</strong>）用来存储栈的最小元素。</p>
<p><strong>思路：</strong>如果当前人栈的元素比原来栈中的最小值还小，则把这个值压入保存最小元素的栈中；在岀栈时，如果当前出栈的元素恰好为当前栈中的最小值，保存最小值的栈顶元素也出栈，使得当前最小值变为其人栈之前的那个最小值。</p>
<p><strong>顺便加入求最大值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 栈的使用  高效求栈中的最大最小值 时空复杂度均是O(1)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SpecialStack&lt;E extends Number&gt; &#123;</span><br><span class="line">	Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; stackMin &#x3D; new Stack&lt;Integer&gt;();&#x2F;&#x2F; 存放求最小值的栈</span><br><span class="line">	Stack&lt;Integer&gt; stackMax &#x3D; new Stack&lt;Integer&gt;();&#x2F;&#x2F; 存放求最大值的栈</span><br><span class="line"></span><br><span class="line">	public void push(Integer l) &#123;</span><br><span class="line">		stack.push(l);</span><br><span class="line"></span><br><span class="line">		if(stackMin.isEmpty())&#123;</span><br><span class="line">			stackMin.push(l);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if(l.intValue() &lt;&#x3D; stackMin.peek())&#123;</span><br><span class="line">				stackMin.push(l);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		if(stackMax.isEmpty())&#123;</span><br><span class="line">			stackMax.push(l);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if(l.intValue() &gt; stackMax.peek())&#123;</span><br><span class="line">				stackMax.push(l);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Integer pop()&#x2F;&#x2F; 一定要记着，非空才能pop()</span><br><span class="line">	&#123;</span><br><span class="line">		if (!stack.isEmpty() &amp;&amp; !stackMin.isEmpty() &amp;&amp; !stackMax.isEmpty()) &#123;</span><br><span class="line">			Integer e &#x3D; stack.pop();</span><br><span class="line">			stackMin.pop();</span><br><span class="line">			stackMax.pop();</span><br><span class="line">			return e;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			System.out.println(&quot;栈为空了&quot;);</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Integer getMin() &#123;</span><br><span class="line">		return stackMin.peek();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Integer getMax() &#123;</span><br><span class="line">		return stackMax.peek();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpecialStack&lt;Integer&gt; spect &#x3D; new SpecialStack&lt;Integer&gt;();</span><br><span class="line">		spect.push(2);</span><br><span class="line">		spect.push(1);</span><br><span class="line">		spect.push(4);</span><br><span class="line">		spect.push(7);</span><br><span class="line">		spect.push(5);</span><br><span class="line">				</span><br><span class="line">		System.out.println(&quot;spect.stack1&#x3D;&quot;+spect.stack);</span><br><span class="line">		System.out.println(&quot;spect.stackMin&#x3D;&quot;+spect.stackMin);</span><br><span class="line">		System.out.println(&quot;spect.getMin()&#x3D;&quot;+spect.getMin());</span><br><span class="line">		System.out.println(&quot;spect.stackMax&#x3D;&quot;+spect.stackMax);</span><br><span class="line">		System.out.println(&quot;spect.getMax()&#x3D;&quot;+spect.getMax());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>spect.stack1=[2, 1, 4, 7, 5]<br>spect.stackMin=[2, 1]<br>spect.getMin()=1<br>spect.stackMax=[2, 4, 7]<br>spect.getMax()=7</p>
<h3 id="2-4-实现队列"><a href="#2-4-实现队列" class="headerlink" title="2.4 实现队列"></a>2.4 实现队列</h3><p>队列也可以采用数组和链表两种方式来实现。（<strong>先进先出，后进后岀</strong>）</p>
<p><strong>链表实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&lt;E&gt;&#123;</span><br><span class="line">	Node&lt;E&gt;next &#x3D; null;</span><br><span class="line">	E data;</span><br><span class="line">	public Node(E data) &#123;</span><br><span class="line">		this.data &#x3D; data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyQueue&lt;E&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	private Node&lt;E&gt;head &#x3D; null;</span><br><span class="line">	private Node&lt;E&gt;tail &#x3D; null;</span><br><span class="line">	public boolean isEmpty() &#123;</span><br><span class="line">		return head &#x3D;&#x3D; tail;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;入列</span><br><span class="line">	public void put(E data) &#123;</span><br><span class="line">		Node&lt;E&gt;newNode &#x3D; new Node(data);</span><br><span class="line">		if(head&#x3D;&#x3D;null &amp;&amp; tail&#x3D;&#x3D;null)&#x2F;&#x2F;队列为空</span><br><span class="line">			head &#x3D;tail &#x3D; newNode;</span><br><span class="line">		else &#123;</span><br><span class="line">			tail.next &#x3D; newNode;</span><br><span class="line">			tail &#x3D; newNode ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;出列</span><br><span class="line">	public E pop() &#123;</span><br><span class="line">		if(this.isEmpty())</span><br><span class="line">			return null;</span><br><span class="line">		E data &#x3D; head.data;</span><br><span class="line">		head &#x3D; head.next;</span><br><span class="line">		return data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int size() &#123;</span><br><span class="line">		Node&lt;E&gt;tmp &#x3D; head;</span><br><span class="line">		int n &#x3D; 0;</span><br><span class="line">		while(tmp!&#x3D;null) &#123;</span><br><span class="line">			n++;</span><br><span class="line">			tmp &#x3D; tmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		MyQueue&lt;Integer&gt;q &#x3D; new MyQueue&lt;&gt;();</span><br><span class="line">		q.put(1);</span><br><span class="line">		q.put(2);</span><br><span class="line">		q.put(3);</span><br><span class="line">		System.out.println(&quot;队列长度为:&quot;+q.size());</span><br><span class="line">		System.out.println(&quot;队列首元素为:&quot;+q.pop());</span><br><span class="line">		System.out.println(&quot;队列首元素为:&quot;+q.pop());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>队列长度为:3<br>队列首元素为:1<br>队列首元素为:2</p>
<p><strong>数组实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class MyQueue2&lt;E&gt; &#123;</span><br><span class="line">	private LinkedList&lt;E&gt;list &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	private static int size &#x3D; 0;</span><br><span class="line">	public synchronized void put(E e) &#123;</span><br><span class="line">		list.add(e);</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	public synchronized E pop() &#123;</span><br><span class="line">		size--;</span><br><span class="line">		return list.removeFirst();</span><br><span class="line">	&#125;</span><br><span class="line">	public synchronized boolean empty() &#123;</span><br><span class="line">		return size&#x3D;&#x3D;0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		MyQueue2&lt;Integer&gt; q &#x3D; new MyQueue2&lt;&gt;();</span><br><span class="line">		q.put(1);</span><br><span class="line">		q.put(2);</span><br><span class="line">		q.put(3);</span><br><span class="line">		System.out.println(&quot;队列长度为:&quot;+size);</span><br><span class="line">		System.out.println(&quot;队列首元素为:&quot;+q.pop());</span><br><span class="line">		System.out.println(&quot;队列首元素为:&quot;+q.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br>队列长度为:3<br>队列首元素为:1<br>队列首元素为:2</p>
<h3 id="2-5-两个栈模拟队列操作"><a href="#2-5-两个栈模拟队列操作" class="headerlink" title="2.5 两个栈模拟队列操作"></a>2.5 两个栈模拟队列操作</h3><p>假设使用栈A与栈B模拟队列Q，A为插入栈，B为弹出栈，以实现队列Q。<br>再假设A和B都为空，可以认为栈A提供入队列的功能，栈B提供出队列的功能。</p>
<p>要人队列，入栈A即可，而岀队列则需要分两种情况考虑： </p>
<p>1) 若栈B不为空，则直接弹出栈B的数据。<br>2) 若栈B为空，则依次弹岀栈A的数据，放入栈B中，再弹出找B的数据。</p>
<p>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class MyQueue3&lt;E&gt;&#123;</span><br><span class="line">	private Stack&lt;E&gt;s1 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">	private Stack&lt;E&gt;s2 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	public synchronized void put(E e) &#123;</span><br><span class="line">		s1.push(e);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public synchronized E pop() &#123;</span><br><span class="line">		if(s2.isEmpty())&#x2F;&#x2F;没有s2判断出栈顺序会出错</span><br><span class="line">			while(!s1.isEmpty())</span><br><span class="line">				s2.push(s1.pop());</span><br><span class="line">		return s2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public synchronized boolean empty() &#123;</span><br><span class="line">		return s1.isEmpty()&amp;&amp;s2.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		MyQueue3&lt;Integer&gt;q &#x3D; new MyQueue3&lt;&gt;();</span><br><span class="line">		q.put(1);</span><br><span class="line">		q.put(2);</span><br><span class="line">		q.put(3);</span><br><span class="line">		System.out.println(&quot;队列首元素为:&quot;+q.pop());</span><br><span class="line">		System.out.println(&quot;队列首元素为:&quot;+q.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>队列首元素为:1<br>队列首元素为:2</p>
<h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h2><h3 id="3-1-选择排序"><a href="#3-1-选择排序" class="headerlink" title="3.1 选择排序"></a>3.1 选择排序</h3><p><strong>原理：</strong><br>对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换；接着对不包括第一个记录以外的其他记录进行第二轮比较，得到最小的记录并与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个时为止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestSort &#123;</span><br><span class="line">	</span><br><span class="line">	public static void selectSort(int[]a) &#123;</span><br><span class="line">		int i;</span><br><span class="line">		int j;</span><br><span class="line">		int tmp &#x3D; 0;</span><br><span class="line">		int flag &#x3D; 0;</span><br><span class="line">		int n &#x3D; a.length;</span><br><span class="line">		for(i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">			tmp &#x3D; a[i];</span><br><span class="line">			flag &#x3D; i;</span><br><span class="line">			for(j&#x3D;i+1;j&lt;n;j++) &#123;</span><br><span class="line">				if(a[j]&lt;tmp) &#123;</span><br><span class="line">					tmp &#x3D; a[j];</span><br><span class="line">					flag &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag!&#x3D;1) &#123;</span><br><span class="line">				a[flag] &#x3D; a[i];</span><br><span class="line">				a[i] &#x3D; tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		int a[] &#x3D; &#123;5,4,9,8,7,6,0,1,2,3&#125;;</span><br><span class="line">		selectSort(a);</span><br><span class="line">		for(i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>0 1 2 3 4 5 6 7 8 9 </p>
<p>选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。</p>
<p>所以，综上，简单排序的<strong>时间复杂度为 O(N2)。</strong></p>
<h3 id="3-2-插入排序"><a href="#3-2-插入排序" class="headerlink" title="3.2 插入排序"></a>3.2 插入排序</h3><p>对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余记录为无序序列。 接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中， 直至最后一个记录插入到有序序列中为止。<strong>想象一下打牌时候理牌的顺序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestSort &#123;</span><br><span class="line">	</span><br><span class="line">	public static void InsertSort(int[]a) &#123;</span><br><span class="line">		int i,j;</span><br><span class="line">		int n &#x3D; a.length;</span><br><span class="line">		int target;</span><br><span class="line">			</span><br><span class="line">		 &#x2F;&#x2F;假定第一个元素被放到了正确的位置上</span><br><span class="line">	    &#x2F;&#x2F;这样，仅需遍历1 -- n-1</span><br><span class="line">		for(i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">			j&#x3D;i;</span><br><span class="line">			target &#x3D; a[i];</span><br><span class="line">			while(j&gt;0&amp;&amp;target&lt;a[j-1]) &#123;</span><br><span class="line">				a[j]&#x3D;a[j-1];</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			a[j] &#x3D; target;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		int a[] &#x3D; &#123;5,4,9,8,7,6,0,1,2,3&#125;;</span><br><span class="line">		InsertSort(a);</span><br><span class="line">		for(i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：0 1 2 3 4 5 6 7 8 9 </p>
<p>稳定<br>空间复杂度O(1)<br>时间复杂度O(n2)<br>最差情况：反序，需要移动n*(n-1)/2次元素<br>最好情况：正序，不需要移动元素</p>
<p>数组在已排序或者是“近似排序”时，插入排序效率的最好情况运行时间为O(n)；<br>插入排序最坏情况运行时间和平均情况运行时间都为O(n2)。</p>
<h3 id="3-3-冒泡排序"><a href="#3-3-冒泡排序" class="headerlink" title="3.3 冒泡排序"></a>3.3 冒泡排序</h3><p>比较两个相邻的元素，将值大的元素交换至右端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void BubbleSort(int[]a) &#123;</span><br><span class="line">		int i,j;</span><br><span class="line">		int n &#x3D; a.length;</span><br><span class="line">		int tmp;</span><br><span class="line">		for(i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">			for(j&#x3D;n-1;j&gt;i;j--) &#123;</span><br><span class="line">				if(a[j]&lt;a[j-1]) &#123;</span><br><span class="line">					tmp &#x3D; a[j];</span><br><span class="line">					a[j] &#x3D; a[j-1];</span><br><span class="line">					a[j-1] &#x3D; tmp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序最好的时间复杂度为O(n)。<br>冒泡排序的最坏时间复杂度为：O(n2) 。</p>
<p>*<em>冒泡排序总的平均时间复杂度为：O(n2) *</em></p>
<h3 id="3-4-归并排序"><a href="#3-4-归并排序" class="headerlink" title="3.4 归并排序"></a>3.4 归并排序</h3><p>归并的含义是将两个或两个以上的有序表合并成一个新的有序表。(归是指递归）</p>
<p><strong>1.两路归并排序算法思路</strong><br>分而治之(divide - conquer);每个递归过程涉及三个步骤<br>第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.<br>第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作<br>第三, 合并: 合并两个排好序的子序列,生成排序结果.<br><img src= "/img/loading.gif" data-src="/assets/blogImg/mergeSort.jpg" alt="mergeSort"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">	&#x2F;&#x2F;两路归并算法，两个排好序的子序列合并为一个子序列</span><br><span class="line">	public static void merge(int[]a,int left,int mid,int right) &#123;</span><br><span class="line">		int []tmp &#x3D; new int[a.length];&#x2F;&#x2F;辅助数组</span><br><span class="line">		int p1 &#x3D; left,p2 &#x3D; mid+1,k&#x3D;left;&#x2F;&#x2F;p1、p2是检测指针，k是存放指针</span><br><span class="line">		</span><br><span class="line">		while(p1&lt;&#x3D;mid&amp;&amp;p2&lt;&#x3D;right) &#123;</span><br><span class="line">			if(a[p1]&lt;a[p2])</span><br><span class="line">				tmp[k++] &#x3D; a[p1++];</span><br><span class="line">			else</span><br><span class="line">				tmp[k++] &#x3D; a[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">		while(p1&lt;&#x3D;mid) tmp[k++] &#x3D; a[p1++];&#x2F;&#x2F;如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span><br><span class="line">		while(p2&lt;&#x3D;right) tmp[k++]&#x3D;a[p2++];&#x2F;&#x2F;同上</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;复制回原素组</span><br><span class="line">        for (int i &#x3D; left; i &lt;&#x3D;right; i++) </span><br><span class="line">            a[i]&#x3D;tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 public static void mergeSort(int [] a,int start,int end)&#123;</span><br><span class="line">		 if(start&lt;end)&#123;&#x2F;&#x2F;当子序列中只有一个元素时结束递归</span><br><span class="line">	            int mid&#x3D;(start+end)&#x2F;2;&#x2F;&#x2F;划分子序列</span><br><span class="line">	            mergeSort(a, start, mid);&#x2F;&#x2F;对左侧子序列进行递归排序</span><br><span class="line">	            mergeSort(a, mid+1, end);&#x2F;&#x2F;对右侧子序列进行递归排序</span><br><span class="line">	            merge(a, start, mid, end);&#x2F;&#x2F;合并</span><br><span class="line">	        &#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int[] a &#x3D; &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;;</span><br><span class="line">		mergeSort(a, 0, a.length-1);</span><br><span class="line">		System.out.println(&quot;排好序的数组：&quot;);</span><br><span class="line">		for (int e : a)</span><br><span class="line">            System.out.print(e+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。</strong></p>
<h3 id="3-5-快速排序"><a href="#3-5-快速排序" class="headerlink" title="3.5 快速排序"></a>3.5 快速排序</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_26122557/article/details/79458649" target="_blank" rel="noopener">快速排序——JAVA实现</a><a href="https://blog.csdn.net/qq_26122557/article/details/79458649" target="_blank" rel="noopener">快速排序——JAVA实现</a></p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="/assets/blogImg/quickSort.jpg" alt="quickSort"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">	public static void quickSort(int[]arr,int low,int high)&#123;</span><br><span class="line">		int i,j,tmp,t;</span><br><span class="line">		if(low&gt;high)</span><br><span class="line">			return;</span><br><span class="line">		</span><br><span class="line">		i&#x3D;low;</span><br><span class="line">		j&#x3D;high;</span><br><span class="line">		&#x2F;&#x2F;tmp是基准位</span><br><span class="line">		tmp &#x3D; arr[low];</span><br><span class="line">		</span><br><span class="line">		while(i&lt;j) &#123;</span><br><span class="line">            &#x2F;&#x2F;先看右边，依次往左递减</span><br><span class="line">			while(tmp&lt;&#x3D;arr[j]&amp;&amp;i&lt;j) &#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">            &#x2F;&#x2F;再看左边，依次往右递增</span><br><span class="line">			while(tmp&gt;&#x3D;arr[i]&amp;&amp;i&lt;j) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">            &#x2F;&#x2F;如果满足条件则交换</span><br><span class="line">			if(i&lt;j) &#123;</span><br><span class="line">				t &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; arr[i];</span><br><span class="line">				arr[i] &#x3D; t;			</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">        &#x2F;&#x2F;最后将基准为与i和j相等位置的数字交换</span><br><span class="line">		arr[low] &#x3D; arr[i];</span><br><span class="line">		arr[i] &#x3D; tmp;</span><br><span class="line">        &#x2F;&#x2F;递归调用左半数组</span><br><span class="line">		quickSort(arr, low, j-1);</span><br><span class="line">        &#x2F;&#x2F;递归调用右半数组</span><br><span class="line">        quickSort(arr, j+1, high);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">        int[] arr &#x3D; &#123;10,7,2,4,7,62,3,4,2,1,8,9,19&#125;;</span><br><span class="line">        quickSort(arr, 0, arr.length-1);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong><br>多数情况下的时间复杂度为 O(nlogn)<br>最坏情况是 O(n²)</p>
<h2 id="4-位运算"><a href="#4-位运算" class="headerlink" title="4. 位运算"></a>4. 位运算</h2><h3 id="4-1-移位操作实现乘法"><a href="#4-1-移位操作实现乘法" class="headerlink" title="4.1 移位操作实现乘法"></a>4.1 移位操作实现乘法</h3><p>java中有三种移位运算符</p>
<p><strong>1.左移</strong><br>    左移运算符“&lt;&lt;” - 使指定值的所有位都左移规定的次数。<br>    左移m&lt;&lt;n 代表把数字m在无溢出的前提下乘以2的n次方。</p>
<pre><code>例如，5&lt;&lt;3 就是5乘以2的3次方，结果是40。</code></pre><p><strong>2.右移</strong><br>　右移运算符“&gt;&gt;” - 使指定值的所有位都右移规定的次数。<br>   右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数。注意，如果是单数，也就是二进制末    位为1，则结果是将m除以2的n次方的整数商。</p>
<pre><code>例如，16&gt;&gt;3 就是16除以2的3次方，结果是2。

         15&gt;&gt;3 就是14(15-1)除以2的3次方，结果是1。</code></pre><p><strong>3.无符号右移</strong><br>    无符号右移运算符“&gt;&gt;&gt;” - 同右移，但是结果全变正数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Muti &#123;</span><br><span class="line">	public static int powerN(int m,int n) &#123;&#x2F;&#x2F;m乘以2的n次方</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">			m&#x3D;m&lt;&lt;1;</span><br><span class="line">		&#125;</span><br><span class="line">		return m;	</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">			System.out.println(&quot;3乘以8&#x3D;&quot; +powerN(3, 3));</span><br><span class="line">			System.out.println(&quot;3乘以16&#x3D;&quot; +powerN(3, 4));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-判断一个数是否为2的n次方"><a href="#4-2-判断一个数是否为2的n次方" class="headerlink" title="4.2 判断一个数是否为2的n次方"></a>4.2 判断一个数是否为2的n次方</h3><p>用1做移位操作，然后判断移位后的值是否与给定的数相等，具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static boolean isPower(int n) &#123;</span><br><span class="line">		if(n&lt;1)</span><br><span class="line">			return false;</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		while(i&lt;&#x3D;n) &#123;</span><br><span class="line">			if(i&#x3D;&#x3D;n)</span><br><span class="line">				return true;</span><br><span class="line">			i&#x3D;i&lt;&lt;1;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">			System.out.println(isPower(4));</span><br><span class="line">			System.out.println(isPower(6));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>true;<br>false;<br><strong>改进</strong><br>从二进制的表 示可以看出，如果一个数是2的n次方，那么这个数对应的二进制表示中只有一位是1，其余 位都为0。<br>因此，判断一个数是否为2的n次方可以转换为这个数对应的二进制表示中是否只有一位为1。</p>
<p>例如nunm =00010000,那么num - 1的二 进制表示为num - 1 = 00001111，由于num与num - 1二进制表示中每一位都不相同，因此num&amp;(num-1)<br>的运算结果为0的运算结果为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isPower(int n) &#123;</span><br><span class="line">	if(n&lt;1)</span><br><span class="line">		return false;</span><br><span class="line">	int m &#x3D; n&amp;(n-1);</span><br><span class="line">	return m&#x3D;&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-二进制数中1的个数"><a href="#4-3-二进制数中1的个数" class="headerlink" title="4.3 二进制数中1的个数"></a>4.3 二进制数中1的个数</h3><p>首先，判断这个数的最后一位是否为1， 如果为1，则计数器加1,然后，通过右移丢弃掉最后一位。循环执行该操作直到这个数等于 0为止。在判断二进制表示的最后一位是否为1时，可以采用与运算来达到这个目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static int countOne(int n) &#123;</span><br><span class="line">		int count &#x3D; 0;</span><br><span class="line">		while(n&gt;0) &#123;</span><br><span class="line">			if((n&amp;1)&#x3D;&#x3D;1) &#123;&#x2F;&#x2F;判断最后一位是否为1</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			n&#x3D;n&gt;&gt;1;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">			System.out.println(countOne(7));</span><br><span class="line">			System.out.println(countOne(8));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br>3<br>1</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">鱼歌唱晚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://x2yu.com/2019/04/09/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AF%87/">http://x2yu.com/2019/04/09/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://x2yu.com" target="_blank">阿鱼的碎碎念</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/assets/cover/mysql_random.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E9%A2%98/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库练习题</div></div></a></div><div class="next-post pull-right"><a href="/2019/04/06/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java程序员-设计模式篇</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/04/21/Java程序员-数据结构与算法续篇/" title="Java程序员-数据结构与算法续篇"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-21</div><div class="relatedPosts_title">Java程序员-数据结构与算法续篇</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/06/Java-List去重问题/" title="Java - List去重问题"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-06</div><div class="relatedPosts_title">Java - List去重问题</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/08/排序算法小结/" title="经典排序算法"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-08</div><div class="relatedPosts_title">经典排序算法</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/13/JUC问题总结/" title="JAVA JUC基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-13</div><div class="relatedPosts_title">JAVA JUC基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/15/JVM问题总结/" title="JAVA JVM基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-15</div><div class="relatedPosts_title">JAVA JVM基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/10/数据库练习题/" title="数据库练习题"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-10</div><div class="relatedPosts_title">数据库练习题</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'yYMa3RDNdOAWjpBmszEXyu3y-gzGzoHsz',
  appKey: '4gdOiHj0hxa5OGKFUHxhKad2',
  placeholder: '随心所欲，畅所欲言(´▽`ʃ♡ƪ)',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 鱼歌唱晚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>