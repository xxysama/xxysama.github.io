<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java程序员-数据库原理篇 | 阿鱼的碎碎念</title><meta name="description" content="后端开发的必备基础。   参考链接：数据库常见面试题(开发者篇) 1.1 SQL语言的功能有哪些SQL是结构化查询语言，其功能包括数据査询、数据操纵、数据定义和数据控制4个部分。  基本的 SQL 语句有 select、insert、update、delete、create、drop、grant、revoke等。 drop、delete与truncate分别在什么场景之下使用？drop table"><meta name="keywords" content="面试,数据库原理基础"><meta name="author" content="Ayu"><meta name="copyright" content="Ayu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="http://x2yu.com/2019/04/03/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AF%87/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java程序员-数据库原理篇"><meta property="og:url" content="http://x2yu.com/2019/04/03/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AF%87/"><meta property="og:site_name" content="阿鱼的碎碎念"><meta property="og:description" content="后端开发的必备基础。   参考链接：数据库常见面试题(开发者篇) 1.1 SQL语言的功能有哪些SQL是结构化查询语言，其功能包括数据査询、数据操纵、数据定义和数据控制4个部分。  基本的 SQL 语句有 select、insert、update、delete、create、drop、grant、revoke等。 drop、delete与truncate分别在什么场景之下使用？drop table"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-04-03T06:58:58.000Z"><meta property="article:modified_time" content="2020-07-16T09:41:05.828Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Java程序员-设计模式篇" href="http://x2yu.com/2019/04/06/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/"><link rel="next" title="Java程序员--Java Web篇" href="http://x2yu.com/2019/03/31/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java-Web%E7%AF%87/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">36</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#后端开发的必备基础。"><span class="toc-number">1.</span> <span class="toc-text">后端开发的必备基础。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-number"></span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-SQL语言的功能有哪些"><span class="toc-number">1.</span> <span class="toc-text">1.1 SQL语言的功能有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-内连接与外连接有什么区别"><span class="toc-number">2.</span> <span class="toc-text">1.2 内连接与外连接有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-什么是事务"><span class="toc-number">3.</span> <span class="toc-text">1.3 什么是事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-什么是存储过程？它与函数有什么区别与联系"><span class="toc-number">4.</span> <span class="toc-text">1.4 什么是存储过程？它与函数有什么区别与联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-三大范式"><span class="toc-number">5.</span> <span class="toc-text">1.5 三大范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-什么是触发器"><span class="toc-number">6.</span> <span class="toc-text">1.6 什么是触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-索引是什么？有什么作用以及优缺点？"><span class="toc-number">7.</span> <span class="toc-text">1.7 索引是什么？有什么作用以及优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8什么是视图？以及视图的使用场景有哪些？"><span class="toc-number">8.</span> <span class="toc-text">1.8什么是视图？以及视图的使用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-union和union-all有什么区别"><span class="toc-number">9.</span> <span class="toc-text">1.9 union和union all有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-数据库的乐观锁和悲观锁是什么？"><span class="toc-number">10.</span> <span class="toc-text">1.10 数据库的乐观锁和悲观锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-超键、候选键、主键、外键分别是什么？"><span class="toc-number">11.</span> <span class="toc-text">1.11 超键、候选键、主键、外键分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-SQL-约束有哪几种？"><span class="toc-number">12.</span> <span class="toc-text">1.12 SQL 约束有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"><span class="toc-number">13.</span> <span class="toc-text">1.13 MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-varchar和char的区别"><span class="toc-number">14.</span> <span class="toc-text">1.14 varchar和char的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-如何优化MySQL"><span class="toc-number">15.</span> <span class="toc-text">1.15 如何优化MySQL</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">阿鱼的碎碎念</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java程序员-数据库原理篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-04-03 14:58:58"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2019-04-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-16 17:41:05"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-16</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 26 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="后端开发的必备基础。"><a href="#后端开发的必备基础。" class="headerlink" title="后端开发的必备基础。"></a><center>后端开发的必备基础。</center></h3><center><img src= "/img/loading.gif" data-src="/assets/blogImg/databases.jpg" width="40%" height="40%">
</center>

<p>参考链接：<a href="https://segmentfault.com/a/1190000013517914" target="_blank" rel="noopener">数据库常见面试题(开发者篇)</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><center><img src= "/img/loading.gif" data-src="/assets/blogImg/data_structure.jpg" width="50%" height="50%"></center></h2><h3 id="1-1-SQL语言的功能有哪些"><a href="#1-1-SQL语言的功能有哪些" class="headerlink" title="1.1 SQL语言的功能有哪些"></a>1.1 SQL语言的功能有哪些</h3><p>SQL是结构化查询语言，其功能包括<strong>数据査询、数据操纵、数据定义和数据控制</strong>4个部分。</p>
<a id="more"></a>
<p>基本的 SQL 语句有 select、insert、update、delete、create、drop、grant、revoke等。<br><img src= "/img/loading.gif" data-src="/assets/blogImg/SQL.png" alt="SQL"></p>
<p><strong>drop、delete与truncate分别在什么场景之下使用？</strong><br>drop table</p>
<ul>
<li>1)属于DDL</li>
<li>2)不可回滚</li>
<li>3)不可带where</li>
<li>4)表内容和结构删除</li>
<li>5)删除速度快</li>
</ul>
<p>truncate table</p>
<ul>
<li>1)属于DDL</li>
<li>2)不可回滚</li>
<li>3)不可带where</li>
<li>4)表内容删除</li>
<li>5)删除速度快</li>
</ul>
<p>delete from</p>
<ul>
<li>1)属于DML</li>
<li>2)可回滚</li>
<li>3)可带where</li>
<li>4)表结构在，表内容要看where执行的情况</li>
<li>5)删除速度慢,需要逐行删除</li>
</ul>
<p><strong>不再需要一张表的时候，用drop</strong><br><strong>想删除部分数据行时候，用delete，并且带上where子句</strong><br><strong>保留表而删除所有数据的时候用truncate</strong></p>
<p><strong>注意：</strong>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
<p>也是这样所以Delete 删除的数据是可以恢复的。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/zhizhao/p/7825469.html" target="_blank" rel="noopener">drop、truncate和delete的区别详细补充</a></p>
</blockquote>
<p>例题：<br>Oracle数据库的一个表中有若干条数据，其占用的存储空间为10MB，如果用delete语句删除表中的所有数据，此时该表所占存储空间为多大？ </p>
<p>答案：10MB。数据库中delete操作类似于在Windows系统中把数据放到回收站，还可以恢复， 因此它不会立即释放所占的存储空间。如果想在删除数据后立即释放存储空间，可以使用truncate。</p>
<h3 id="1-2-内连接与外连接有什么区别"><a href="#1-2-内连接与外连接有什么区别" class="headerlink" title="1.2 内连接与外连接有什么区别"></a>1.2 内连接与外连接有什么区别</h3><p>内连接，也被称为自然连接，只有两个表相匹配的行才能在结果集中出现。返回的结果集选取了两个表中所有相匹配的数据，舍弃了不匹配的数据，所以内连接可能会造成信息的丢失。<br><code>select fieldlist from table 1 [ inner] join table2 on table 1. column = table2. column</code></p>
<p>外连接不仅包含符合连接条件的行，而且还包括左表（左外连接时）、右表（右外连接时）或两个边接表（全外连接）中的所有数据行。</p>
<p>示例：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/courses.png" alt="student"> <img src= "/img/loading.gif" data-src="/assets/blogImg/student.png" alt="courses"><br><strong>1.内连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student,courses where student.&#96;学号&#96; &#x3D; courses.&#96;学号&#96;;</span><br><span class="line">select * from student join courses on student.&#96;学号&#96; &#x3D; courses.&#96;学号&#96;;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/assets/blogImg/innerResult.png" alt="innerResult"></p>
<p><strong>2.外连接</strong></p>
<p>1)左连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student left join courses on student.&#96;学号&#96; &#x3D; courses.&#96;学号&#96;;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/assets/blogImg/leftResult.png" alt="leftResult"><br>2)右连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student right join courses on student.&#96;学号&#96; &#x3D; courses.&#96;学号&#96;;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/assets/blogImg/rightResult.png" alt="rightResult"><br>3)全连接<br>MySQL目前不支持此种方式。</p>
<h3 id="1-3-什么是事务"><a href="#1-3-什么是事务" class="headerlink" title="1.3 什么是事务"></a>1.3 什么是事务</h3><p>事务是数据库中一个单独的执行单元(Unit)。当在数据库中更改数据成功时，在事务中更改的数据便会提交，不再改变。否则，事务就取消或者回滚，更改无效。</p>
<p>事务必须满足4个属性，即<strong>原子性（atomicity)、一致性（consistency)、隔离性(isola­ tion)、持久性（durability)，即ACID4种属性。</strong></p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行</li>
<li>一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行        </li>
<li></li>
<li>持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存。</li>
</ol>
<p>示例：</p>
<p> A和B账户都有1000块，现在我让A账户向B账号转500块钱（JDBC默认的情况下是关闭事务的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;A账户减去500元</span><br><span class="line">String sql &#x3D; &quot;update money set money &#x3D; money-500 where name &#x3D; &#39;A&#39;&quot;;</span><br><span class="line">PreparedStatement preparedStatement &#x3D; c.prepareStatement(sql);</span><br><span class="line">preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;B账户增加500元</span><br><span class="line">String sql2 &#x3D; &quot;update money set money &#x3D; money+500 where name &#x3D; &#39;B&#39;&quot;;</span><br><span class="line">PreparedStatement preparedStatement2 &#x3D; c.prepareStatement(sql2);</span><br><span class="line">preparedStatement2.executeUpdate();</span><br></pre></td></tr></table></figure>
<p>我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;A账户减去500元</span><br><span class="line">			String sql &#x3D; &quot;update money set money &#x3D; money-500 where name &#x3D; &#39;A&#39;&quot;;</span><br><span class="line">			PreparedStatement preparedStatement &#x3D; c.prepareStatement(sql);</span><br><span class="line">			preparedStatement.executeUpdate();</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;出现问题</span><br><span class="line">			int a &#x3D; 3&#x2F;0;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;B账户增加500元</span><br><span class="line">			String sql2 &#x3D; &quot;update money set money &#x3D; money+500 where name &#x3D; &#39;B&#39;&quot;;</span><br><span class="line">			PreparedStatement preparedStatement2 &#x3D; c.prepareStatement(sql2);</span><br><span class="line">			preparedStatement2.executeUpdate();</span><br></pre></td></tr></table></figure>
<p>上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。<br><img src= "/img/loading.gif" data-src="/assets/blogImg/updateMoney.png" alt="updateMoney"></p>
<p>通过事务来解决上面出现的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开启事务,对数据的操作就不会立即生效。</span><br><span class="line">		    c.setAutoCommit(false);</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;A账户减去500元</span><br><span class="line">			String sql &#x3D; &quot;update money set money &#x3D; money-500 where name &#x3D; &#39;A&#39;&quot;;</span><br><span class="line">			PreparedStatement preparedStatement &#x3D; c.prepareStatement(sql);</span><br><span class="line">			preparedStatement.executeUpdate();</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;出现问题</span><br><span class="line">			int a &#x3D; 3&#x2F;0;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;B账户增加500元</span><br><span class="line">			String sql2 &#x3D; &quot;update money set money &#x3D; money+500 where name &#x3D; &#39;B&#39;&quot;;</span><br><span class="line">			PreparedStatement preparedStatement2 &#x3D; c.prepareStatement(sql2);</span><br><span class="line">			preparedStatement2.executeUpdate();</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F; 如果程序能执行到这里，没有抛出异常，我们就提交数据</span><br><span class="line">		    c.commit();</span><br><span class="line"></span><br><span class="line">		    &#x2F;&#x2F; 关闭事务【自动提交】</span><br><span class="line">		    c.setAutoCommit(true);</span><br><span class="line">			</span><br><span class="line">		&#125; catch (SQLException e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F; 如果出现了异常，就会进到这里来，我们就把事务回滚</span><br><span class="line">		        c.rollback();</span><br><span class="line"></span><br><span class="line">		        &#x2F;&#x2F; 关闭事务【自动提交】</span><br><span class="line">		        c.setAutoCommit(true);</span><br><span class="line">				</span><br><span class="line">			&#125; catch (Exception e2) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。</p>
<p><strong>注意</strong>：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。</p>
<p><strong>扩展：</strong><br> <strong>1）事务的并发问题有哪几种？</strong></p>
<ol>
<li>丢失更新：一个事务的更新覆盖了另一个事务的更新；</li>
<li>脏读：一个事务读取了另一个事务未提交的数据；</li>
<li>不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；</li>
<li>幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。</li>
</ol>
<p><strong>2) 事务的隔离级别有哪几种？</strong><br>隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是：</p>
<ol>
<li>读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题；</li>
<li>读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题；</li>
<li>可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。</li>
<li>序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。</li>
</ol>
<p><strong>MySQL默认的隔离级别是可重复读（REPEATABLE READ）</strong><br>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：</p>
<ul>
<li>MyISAM：不支持事务，用于只读程序提高性能；</li>
<li>InnoDB：支持ACID事务、行级锁、并发；</li>
<li>Berkeley DB：支持事务。</li>
</ul>
<h3 id="1-4-什么是存储过程？它与函数有什么区别与联系"><a href="#1-4-什么是存储过程？它与函数有什么区别与联系" class="headerlink" title="1.4 什么是存储过程？它与函数有什么区别与联系"></a>1.4 什么是存储过程？它与函数有什么区别与联系</h3><p>SQL语句在执行时要先编译，然后再被执行。在大型数据库系统中，为了提高效率，将为 了完成特定功能的SQL语句集进行编译优化后，存储在数据库服务器中，用户通过指定存储 过程的名字来调用执行。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;NewProc&#96;(OUT &#96;getMoney&#96; varchar(11))</span><br><span class="line">BEGIN</span><br><span class="line">	select * from money where name &#x3D; &#39;A&#39;;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>调用存储过程语法：  exec  sp_name  [参数名]<br>删除存储过程语法：  drop  procedure  sp_name</p>
<p>存储过程不等于函数，二者虽然本质上没有区别，但还是有如下几个方面 的不同： </p>
<p>1) 存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。由于函数可以返回一个对象，因此它可以在查询语句中位于From关键字的后面。<br>2) 一般而言，存储过程实现的功能较复杂，而函数实现的功能针对性较强。<br>3) 函数需要用括号包住输入的参数，且只能返回一个值或表对象，而存储过程可以返回多个参数。<br>4) 函数可以嵌入在SQL中使用，可以在select中调用，存储过程则不行。<br>5) 函数不能直接操作实体表，只能操作内建表。<br>6) 存储过程在创建时即在服务器上进行了编译，其执行速度比函数快</p>
<p>存储过程的优点：</p>
<ul>
<li><strong>能够将代码封装起来</strong></li>
<li><strong>保存在数据库之中</strong></li>
<li><strong>让编程语言进行调用</strong></li>
<li><strong>存储过程是一个预编译的代码块，执行效率比较高</strong></li>
<li><strong>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</strong></li>
</ul>
<p>存储过程的缺点：</p>
<ul>
<li><strong>每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）</strong></li>
<li><strong>业务逻辑放在数据库上，难以迭代</strong></li>
</ul>
<h3 id="1-5-三大范式"><a href="#1-5-三大范式" class="headerlink" title="1.5 三大范式"></a>1.5 三大范式</h3><p>我们现在需要建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号（Sno）、所在系（Sdept）、系主任姓名（Mname）、课程号（Cno）和成绩（Grade），假设我们使用单一的关系模式 Student 来表示，会描述成以下这个样子：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/fanshi_1.png" alt="fanshi_1"></p>
<p>这个关系模式存在以下问题：<br><strong>（1） 数据冗余</strong><br>比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，这将浪费大量的存储空间。<br><strong>（2）更新异常（update anomalies）</strong><br>由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。比如，某系更换系主任后，必须修改与该系学生有关的每一个元组。<br><strong>（3）插入异常（insertion anomalies）</strong><br>如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。<br><strong>（4）删除异常（deletion anomalies）</strong><br>如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢失了。</p>
<p><strong>第一范式：</strong>列不可分<br>1NF（第一范式）是对属性具有<strong>原子性</strong>的要求，不可再分，例如：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/fanshi_2.png" alt="fanshi_2"><br>如果认为最后一列还可以再分成出生年，出生月，出生日，则它就不满足第一范式的要求。</p>
<p><strong>第二范式：</strong> 消除非主属性对码的部分函数依赖<br>2NF（第二范式）是对记录有<strong>唯一性</strong>的要求，即实体的唯一性，不存在部分依赖，每一列与主键都相关，例如：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/fanshi_3.png" alt="fanshi_3"><br>该表明显说明了两个事物：学生信息和课程信息；正常的依赖应该是：学分依赖课程号，姓名依赖学号，但这里存在非主键字段对码的部分依赖，即与主键不相关，不满足第二范式的要求。</p>
<p>正确做法：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/fanshi_4.png" alt="fanshi_4"></p>
<p><strong>第三范式：</strong> 消除非主属性对码的传递函数依赖<br>3NF（第三范式）对字段有<strong>冗余性</strong>的要求，任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖。</p>
<p><strong>传递函数依赖：</strong>设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p>
<blockquote>
<p>举个例子：通过A得到B，通过B得到C，B得不到A，那么成C传递依赖于A</p>
</blockquote>
<p>例如：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/fanshi_5.png" alt="fanshi_5"><br>很明显，学院电话是一个冗余字段，存在依赖传递：（学号）→（学院）→（学院电话）</p>
<p>正确做法：<br><img src= "/img/loading.gif" data-src="/assets/blogImg/fanshi_6.png" alt="fanshi_6"></p>
<h3 id="1-6-什么是触发器"><a href="#1-6-什么是触发器" class="headerlink" title="1.6 什么是触发器"></a>1.6 什么是触发器</h3><p>触发器是一种特殊类型的存储过程，它由事件触发，而不是程序调用或手工启动，当数据 库有特殊的操作时，这些操作由数据库中的事件来触发，自动完成这些SQL语句。使用触发 器可以用来保证数据的有效性和完整性，完成比约束更复杂的数据约束。</p>
<p>简单俩说：也就是对某一个表的一定的操作，触发某种条件，从而执行的一段程序。触发器是一个特殊的存储过程。</p>
<p>实例：<br>假如有这么两张表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Create Table Student(              --学生表 </span><br><span class="line">       StudentID int primary key,       --学号 </span><br><span class="line">       .... </span><br><span class="line">      ) </span><br><span class="line"></span><br><span class="line">Create Table BorrowRecord(               --学生借书记录表 </span><br><span class="line">       BorrowRecord   int identity(1,1),       --流水号   </span><br><span class="line">       StudentID      int ,                    --学号 </span><br><span class="line">       BorrowDate     datetime,                --借出时间 </span><br><span class="line">       ReturnDAte     Datetime,                --归还时间 </span><br><span class="line">       ... </span><br><span class="line">     )</span><br></pre></td></tr></table></figure>

<p>功能有：<br>1.如果我更改了学生的学号,我希望他的借书记录仍然与这个学生相关(也就是同时更改借书记录表的学号);<br>2.如果该学生已经毕业，我希望删除他的学号的同时，也删除它的借书记录。</p>
<p>这时候可以用到触发器。对于1，创建一个Update触发器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Create Trigger truStudent </span><br><span class="line">      On Student                         --在Student表中创建触发器 </span><br><span class="line">      for Update                          --为什么事件触发 </span><br><span class="line">    As                                        --事件触发后所要做的事情 </span><br><span class="line">      if Update(StudentID)            </span><br><span class="line">      begin </span><br><span class="line"></span><br><span class="line">        Update BorrowRecord </span><br><span class="line">          Set StudentID&#x3D;i.StudentID </span><br><span class="line">          From BorrowRecord br , Deleted   d ,Inserted i      --Deleted和Inserted临时表 </span><br><span class="line">          Where br.StudentID&#x3D;d.StudentID </span><br><span class="line">      end</span><br></pre></td></tr></table></figure>

<p>理解触发器里面的两个临时的表：Deleted , Inserted 。注意Deleted 与Inserted分别表示触发事件的表“旧的一条记录”和“新的一条记录”。<br>一个数据库系统中有两个虚拟表用于存储在表中记录改动的信息，分别是： </p>
<table>
<thead>
<tr>
<th align="center">操作时</th>
<th align="center">虚拟表Inserted</th>
<th align="center">拟表Deleted</th>
</tr>
</thead>
<tbody><tr>
<td align="center">在表记录新增时</td>
<td align="center">存放新增的记录</td>
<td align="center">不存储记录</td>
</tr>
<tr>
<td align="center">修改时</td>
<td align="center">存放用来更新的新记录</td>
<td align="center">存放更新前的记录</td>
</tr>
<tr>
<td align="center">删除时</td>
<td align="center">不存储记录</td>
<td align="center">存放被删除的记录</td>
</tr>
</tbody></table>
<p>对于2，创建一个Delete触发器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Create trigger trdStudent </span><br><span class="line">      On Student </span><br><span class="line">      for Delete </span><br><span class="line">    As </span><br><span class="line">      Delete BorrowRecord </span><br><span class="line">        From BorrowRecord br , Delted d </span><br><span class="line">        Where br.StudentID&#x3D;d.StudentID</span><br></pre></td></tr></table></figure>

<h3 id="1-7-索引是什么？有什么作用以及优缺点？"><a href="#1-7-索引是什么？有什么作用以及优缺点？" class="headerlink" title="1.7 索引是什么？有什么作用以及优缺点？"></a>1.7 索引是什么？有什么作用以及优缺点？</h3><blockquote>
<p> 参考理解：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
</blockquote>
<blockquote>
<p>什么是索引【Index】</p>
</blockquote>
<p>   （1）<strong>是一种快速查询表中内容的机制，类似于新华字典的目录</strong><br>   （2）<strong>运用在表中某个些字段上，但存储时，独立于表之外</strong></p>
<blockquote>
<p>底层数据结构是什么，为什么使用这种数据结构？</p>
</blockquote>
<p><strong>（1）底层数据结构是B+树：</strong><br>MySQL就普遍使用B+Tree实现其索引结构。在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。</p>
<p><strong>2）使用B+树的原因：</strong><br>查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（画出什么是B+树）</p>
<blockquote>
<p>索引的分类？</p>
</blockquote>
<p>   <strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值<br>   <strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空<br>   <strong>聚集索引</strong>(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个<br>   <strong>非聚集索引</strong>(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</p>
<blockquote>
<p>索引的优缺点？</p>
</blockquote>
<p><strong>（1）优点：</strong><br>   1.<strong>大大加快数据的检索速度</strong>，这也是创建索引的最主要的原因；<br>   2.加速表和表之间的连接；<br>   3.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；<br>   4.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</p>
<p><strong>（2）缺点：</strong><br>1.时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；<br>2.空间方面：索引需要占物理空间。</p>
<blockquote>
<p>什么样的字段适合创建索引？</p>
</blockquote>
<ul>
<li>经常作查询SELECT的字段</li>
<li>经常作表连接的字段</li>
<li>经常出现在order by, group by, distinct 后面的字段</li>
</ul>
<blockquote>
<p>创建索引时需要注意什么？</p>
</blockquote>
<p>   <strong>非空字段</strong>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
<p>   <strong>取值离散大的字段</strong>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>
<p>  <strong>索引字段越小越好</strong>：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>
<h3 id="1-8什么是视图？以及视图的使用场景有哪些？"><a href="#1-8什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="1.8什么是视图？以及视图的使用场景有哪些？"></a>1.8什么是视图？以及视图的使用场景有哪些？</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。<strong>对视图的修改不影响基本表。</strong>它使得我们获取数据更容易，相比多表查询。</p>
<p>如下两种场景一般会使用到视图：</p>
<ol>
<li>不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。</li>
</ol>
<p><strong>注意</strong>：这个视图是在数据库中创建的 而不是用代码创建的。</p>
<p>简单示例：<br>为之前的学生和成绩表两表创建视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view stu_and_cou </span><br><span class="line">as</span><br><span class="line">select student.id,student.name,courses.cname</span><br><span class="line">from student,courses </span><br><span class="line">where student.id &#x3D; courses.id ;</span><br></pre></td></tr></table></figure>

<p>使用视图：<br><code>select * from stu_and_cou;</code><br><img src= "/img/loading.gif" data-src="/assets/blogImg/sql_view.png" alt="sql_view"></p>
<h3 id="1-9-union和union-all有什么区别"><a href="#1-9-union和union-all有什么区别" class="headerlink" title="1.9 union和union all有什么区别"></a>1.9 union和union all有什么区别</h3><p><strong>union在进行表求并集后会去掉重复的元素</strong>，所以会对所产生的结果集进行排序运算，删除重复的记录再返回结果。 </p>
<p><strong>union  all</strong>则只是简单地将两个结果集合并后就返回结果。因此，如果返回的两个结果集中 <strong>有重复的数据</strong>，那么返回的结果集就会包含重复的数据。</p>
<h3 id="1-10-数据库的乐观锁和悲观锁是什么？"><a href="#1-10-数据库的乐观锁和悲观锁是什么？" class="headerlink" title="1.10 数据库的乐观锁和悲观锁是什么？"></a>1.10 数据库的乐观锁和悲观锁是什么？</h3><blockquote>
<p>参考文章：<a href="https://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></p>
</blockquote>
<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p><strong>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</strong><br>1.在查询完数据的时候就把事务锁起来，直到提交事务<br>2.实现方式：使用数据库中的锁机制<br>这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了，这就是悲观锁的实现方式。</p>
<p>场景：商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。</p>
<p><strong>MySQL InnoDB中使用悲观锁：</strong></p>
<p>注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &#x2F;&#x2F;0.开始事务</span><br><span class="line">&gt; </span><br><span class="line">&gt; begin;&#x2F;begin work;&#x2F;start transaction; (三者选一就可以)</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#x2F;&#x2F;1.查询出商品信息</span><br><span class="line">&gt; </span><br><span class="line">&gt; select status from t_goods where id&#x3D;1 for update;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#x2F;&#x2F;2.根据商品信息生成订单</span><br><span class="line">&gt; </span><br><span class="line">&gt; insert into t_orders (id,goods_id) values (null,1);</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#x2F;&#x2F;3.修改商品status为2</span><br><span class="line">&gt; </span><br><span class="line">&gt; update t_goods set status&#x3D;2;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#x2F;&#x2F;4.提交事务</span><br><span class="line">&gt; </span><br><span class="line">&gt; commit;&#x2F;commit work;</span><br></pre></td></tr></table></figure>

<p><strong>普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</strong></p>
<p><strong>优点与不足：</strong></p>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
<p><strong>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</strong><br>1.在修改数据的时候把事务锁起来，通过version的方式来进行锁定<br>2.实现方式：使用version版本或者时间戳</p>
<p>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p><strong>使用版本号实现乐观锁：</strong><br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1.查询出商品信息</span><br><span class="line">select (status,status,version) from t_goods where id&#x3D;#&#123;id&#125;</span><br><span class="line">&#x2F;&#x2F;2.根据商品信息生成订单</span><br><span class="line">&#x2F;&#x2F;3.修改商品status为2</span><br><span class="line">update t_goods </span><br><span class="line">set status&#x3D;2,version&#x3D;version+1</span><br><span class="line">where id&#x3D;#&#123;id&#125; and version&#x3D;#&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>优点与不足：</strong><br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<h3 id="1-11-超键、候选键、主键、外键分别是什么？"><a href="#1-11-超键、候选键、主键、外键分别是什么？" class="headerlink" title="1.11 超键、候选键、主键、外键分别是什么？"></a>1.11 超键、候选键、主键、外键分别是什么？</h3><p><strong>超键：</strong>在关系中能唯一标识元组(表每行)的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p><strong>候选键（候选码）：</strong>是最小超键，即没有冗余元素的超键。</p>
<p><strong>主键（主码）：</strong>主键就是候选键里面的一个，数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
<p><strong>外键：</strong>在一个表中存在的另一个表的主键称此表的外键。</p>
<p>示例：<br>假设有如下两个表：</p>
<p>学生（学号，姓名，性别，身份证号，教师编号）<br>教师（教师编号，姓名，工资）</p>
<p>超健：学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。<br>候选键：学生表中的候选键为：（学号）、（身份证号）。<br>主键： 主键就是候选键里面的一个，学生表中，通常会让“学号”做主键，教师表中让“教师编号”做主键。<br>外键：学生表中的外键就是“教师编号”。</p>
<h3 id="1-12-SQL-约束有哪几种？"><a href="#1-12-SQL-约束有哪几种？" class="headerlink" title="1.12 SQL 约束有哪几种？"></a>1.12 SQL 约束有哪几种？</h3><p><strong>NOT NULL：</strong>用于控制字段的内容一定不能为空（NULL）。<br><strong>UNIQUE:</strong>控件字段内容不能重复，一个表允许有多个 Unique 约束。<br><strong>PRIMARY KEY:</strong>也是用于控件字段内容不能重复，但它在一个表只允许出现一个。<br><strong>FOREIGN KEY:</strong>用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。<br>*<em>CHECK: *</em>用于控制字段的值范围。</p>
<h3 id="1-13-MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"><a href="#1-13-MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？" class="headerlink" title="1.13 MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"></a>1.13 MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？</h3><p>答案:都是B+树!</p>
<p>MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，<strong>只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。</strong></p>
<p>Innodb引擎的索引的数据结构也是B+树，<strong>只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索</strong></p>
<h3 id="1-14-varchar和char的区别"><a href="#1-14-varchar和char的区别" class="headerlink" title="1.14 varchar和char的区别"></a>1.14 varchar和char的区别</h3><p>char是一种固定长度的类型，varchar是一种可变长度的类型。<br>例如：<br>定义一个char[10]和varchar[10]，如果存进去的是 ‘test’，那么char所占的长度依然为10，除了字符 ‘test’ 外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，<strong>char类型的要用trim()去掉多余的空格，</strong>而varchar是不需要的。</p>
<p>char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储于查找。</p>
<p>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</p>
<p>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p>
<p>两者的存储数据都非unicode的字符数据。</p>
<h3 id="1-15-如何优化MySQL"><a href="#1-15-如何优化MySQL" class="headerlink" title="1.15 如何优化MySQL"></a>1.15 如何优化MySQL</h3><p><strong>① 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）</strong></p>
<p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。<br><img src= "/img/loading.gif" data-src="/assets/blogImg/query_slow.png" alt="query_slow"><br>通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。</p>
<p><strong>② 通过explain查询和分析SQL的执行计划：</strong><br>使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。</p>
<p><strong>③ SQL语句的优化：</strong></p>
<p><strong>⒈优化insert语句：一次插入多值；</strong></p>
<p><strong>⒉应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描；</strong></p>
<p><strong>⒊应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；</strong></p>
<p><strong>⒋优化嵌套查询：子查询可以被更有效率的连接(Join)替代；</strong></p>
<p><strong>⒌很多时候用 exists 代替 in 是一个好的选择。</strong></p>
<p><strong>⒍选择最有效率的表名顺序：数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p>
<p>在FROM子句中包含多个表的情况下：</p>
<ul>
<li>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</li>
<li>也就是说：选择记录条数最少的表放在最后</li>
</ul>
<p>如果有3个以上的表连接查询：</p>
<ul>
<li>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。</li>
<li>也就是说：被其他表所引用的表放在最后</li>
</ul>
<p><strong>⒎用IN代替OR：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp where sal &#x3D; 1500 or sal &#x3D; 3000 or sal &#x3D; 800;</span><br><span class="line">select * from emp where sal in (1500,3000,800);</span><br></pre></td></tr></table></figure>

<p><strong>⒏SELECT子句中避免使用*号：</strong></p>
<p>我们最开始接触 SQL 的时候，“<code>*</code>” 号是可以获取表中全部的字段数据的，<strong>但是它要通过查询数据字典完成，这意味着将消耗更多的时间</strong>，而且使用 “<code>*</code>” 号写出来的 SQL 语句也不够直观。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ayu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://x2yu.com/2019/04/03/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AF%87/">http://x2yu.com/2019/04/03/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://x2yu.com" target="_blank">阿鱼的碎碎念</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/">数据库原理基础</a></div><div class="post_share"><div class="social-share" data-image="/assets/cover/mysql_random.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/04/06/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java程序员-设计模式篇</div></div></a></div><div class="next-post pull-right"><a href="/2019/03/31/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java-Web%E7%AF%87/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java程序员--Java Web篇</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/04/21/Java程序员-数据结构与算法续篇/" title="Java程序员-数据结构与算法续篇"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-21</div><div class="relatedPosts_title">Java程序员-数据结构与算法续篇</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/15/JVM问题总结/" title="JAVA JVM基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-15</div><div class="relatedPosts_title">JAVA JVM基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/13/JUC问题总结/" title="JAVA JUC基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-13</div><div class="relatedPosts_title">JAVA JUC基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/10/29/正则表达式/" title="正则表达式"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-29</div><div class="relatedPosts_title">正则表达式</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/08/排序算法小结/" title="经典排序算法"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-08</div><div class="relatedPosts_title">经典排序算法</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/10/数据库练习题/" title="数据库练习题"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-10</div><div class="relatedPosts_title">数据库练习题</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Ayu</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>