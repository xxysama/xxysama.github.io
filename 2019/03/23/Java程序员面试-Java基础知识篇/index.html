<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java程序员--java基础知识篇 | 阿鱼的碎碎念</title><meta name="description" content="第一步，慢慢来![java logo](&#x2F;assets&#x2F;blogImg&#x2F;java%20logo.png)  1.基本概念1.1为什么需要public static void mian(String[] args)这个方法该方法为java程序的入口方法，jvm运行时会首先找main()方法。按照必须有public 与static修饰，返回值为void且方法的参数为字符串数组来查找方法的入口地址。"><meta name="keywords" content="面试,java基础"><meta name="author" content="Ayu"><meta name="copyright" content="Ayu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="http://x2yu.com/2019/03/23/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="java程序员--java基础知识篇"><meta property="og:url" content="http://x2yu.com/2019/03/23/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/"><meta property="og:site_name" content="阿鱼的碎碎念"><meta property="og:description" content="第一步，慢慢来![java logo](&#x2F;assets&#x2F;blogImg&#x2F;java%20logo.png)  1.基本概念1.1为什么需要public static void mian(String[] args)这个方法该方法为java程序的入口方法，jvm运行时会首先找main()方法。按照必须有public 与static修饰，返回值为void且方法的参数为字符串数组来查找方法的入口地址。"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-03-23T07:56:03.000Z"><meta property="article:modified_time" content="2020-07-16T09:43:23.756Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Java程序员--Java Web篇" href="http://x2yu.com/2019/03/31/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java-Web%E7%AF%87/"><link rel="next" title="白蛇 缘起" href="http://x2yu.com/2019/03/21/%E7%99%BD%E8%9B%87-%E7%BC%98%E8%B5%B7/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">36</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一步，慢慢来"><span class="toc-number">1.</span> <span class="toc-text">第一步，慢慢来</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-基本概念"><span class="toc-number"></span> <span class="toc-text">1.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1为什么需要public-static-void-mian-String-args-这个方法"><span class="toc-number">0.1.</span> <span class="toc-text">1.1为什么需要public static void mian(String[] args)这个方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2如何实现在main-方法执行前输出“Hello-world”"><span class="toc-number">0.2.</span> <span class="toc-text">1.2如何实现在main()方法执行前输出“Hello world”?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3Java程序初始化的顺序是怎样的"><span class="toc-number">0.3.</span> <span class="toc-text">1.3Java程序初始化的顺序是怎样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4Java中的作用域有哪些"><span class="toc-number">0.4.</span> <span class="toc-text">1.4Java中的作用域有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5一个Java文件中是否可以定义多个类"><span class="toc-number">0.5.</span> <span class="toc-text">1.5一个Java文件中是否可以定义多个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6什么是构造闲数"><span class="toc-number">0.6.</span> <span class="toc-text">1.6什么是构造闲数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7为什么Java中有些接口没有任何方法"><span class="toc-number">0.7.</span> <span class="toc-text">1.7为什么Java中有些接口没有任何方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8Java中的clone方法有什么作用"><span class="toc-number">0.8.</span> <span class="toc-text">1.8Java中的clone方法有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9什么是反射机制"><span class="toc-number">0.9.</span> <span class="toc-text">1.9什么是反射机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10package有什么作用"><span class="toc-number">0.10.</span> <span class="toc-text">1.10package有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11如何实现类似C语言中函数指针的功能"><span class="toc-number">0.11.</span> <span class="toc-text">1.11如何实现类似C语言中函数指针的功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-面向对象技术"><span class="toc-number"></span> <span class="toc-text">2.面向对象技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1面向对象有哪些特征"><span class="toc-number">0.1.</span> <span class="toc-text">2.1面向对象有哪些特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2什么是继承"><span class="toc-number">0.2.</span> <span class="toc-text">2.2什么是继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3组合和继承有什么区別"><span class="toc-number">0.3.</span> <span class="toc-text">2.3组合和继承有什么区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4多态的实现机制是什么"><span class="toc-number">0.4.</span> <span class="toc-text">2.4多态的实现机制是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5重载和覆盖有什么区别"><span class="toc-number">0.5.</span> <span class="toc-text">2.5重载和覆盖有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6抽象类-abstract-class-与接口-interface-有什么异同"><span class="toc-number">0.6.</span> <span class="toc-text">2.6抽象类(abstract class)与接口 (interface)有什么异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7内部类有哪些"><span class="toc-number">0.7.</span> <span class="toc-text">2.7内部类有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8如何获取父类的类名"><span class="toc-number">0.8.</span> <span class="toc-text">2.8如何获取父类的类名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-this与super有什么区別"><span class="toc-number">0.9.</span> <span class="toc-text">2.9 this与super有什么区別</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-关键字"><span class="toc-number"></span> <span class="toc-text">3.关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-break，continue以及return有什么区別"><span class="toc-number">0.1.</span> <span class="toc-text">3.2 break，continue以及return有什么区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-final，finally和finalize有什么区別"><span class="toc-number">0.2.</span> <span class="toc-text">3.3 final，finally和finalize有什么区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-assert存什么作用"><span class="toc-number">0.3.</span> <span class="toc-text">3.4 assert存什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-static关键字有哪些作用"><span class="toc-number">0.4.</span> <span class="toc-text">3.5 static关键字有哪些作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-使用switch时有哪些注意事项"><span class="toc-number">0.5.</span> <span class="toc-text">3.6 使用switch时有哪些注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-volatile有什么作用"><span class="toc-number">0.6.</span> <span class="toc-text">3.7 volatile有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-instanceof有什么作用"><span class="toc-number">0.7.</span> <span class="toc-text">3.8 instanceof有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-strictfp有什么作用"><span class="toc-number">0.8.</span> <span class="toc-text">3.9 strictfp有什么作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-基本类型与运算"><span class="toc-number"></span> <span class="toc-text">4.基本类型与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1Java提供了哪些基本数据类型"><span class="toc-number">0.1.</span> <span class="toc-text">4.1Java提供了哪些基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2什么是不可变类"><span class="toc-number">0.2.</span> <span class="toc-text">4.2什么是不可变类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-值传递与引用传递有哪些区别"><span class="toc-number">0.3.</span> <span class="toc-text">4.3 值传递与引用传递有哪些区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4不同数据类型的转换有哪些规则"><span class="toc-number">0.4.</span> <span class="toc-text">4.4不同数据类型的转换有哪些规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5运算符优先级是什么"><span class="toc-number">0.5.</span> <span class="toc-text">4.5运算符优先级是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6Math类中round、ceil和floor方法的功能各是什么"><span class="toc-number">0.6.</span> <span class="toc-text">4.6Math类中round、ceil和floor方法的功能各是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-如何实现无符号数的占移操作"><span class="toc-number">0.7.</span> <span class="toc-text">4.7 如何实现无符号数的占移操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-char型变量中是否可以存储一个中文汉字"><span class="toc-number">0.8.</span> <span class="toc-text">4.8 char型变量中是否可以存储一个中文汉字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-字符串与数组"><span class="toc-number"></span> <span class="toc-text">5.字符串与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1字符串创建与存储的机制是什么"><span class="toc-number">0.1.</span> <span class="toc-text">5.1字符串创建与存储的机制是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2“-’’、-equals-和-hashCode-有什么区别"><span class="toc-number">0.2.</span> <span class="toc-text">5.2“&#x3D;&#x3D;’’、  equals 和 hashCode 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-String、StringBuffer、-StringBuilder-和-StringTokenizer-什么区別"><span class="toc-number">0.3.</span> <span class="toc-text">5.3 String、StringBuffer、  StringBuilder 和 StringTokenizer 什么区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-Java中数组是不是对象"><span class="toc-number">0.4.</span> <span class="toc-text">5.4 Java中数组是不是对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-数组的初始化方式有哪几种"><span class="toc-number">0.5.</span> <span class="toc-text">5.5 数组的初始化方式有哪几种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-length属性和length-方法有什么区别"><span class="toc-number">0.6.</span> <span class="toc-text">5.6 length属性和length ()方法有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-异常处理"><span class="toc-number"></span> <span class="toc-text">6.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1finally块中的代码什么时候被执行"><span class="toc-number">0.1.</span> <span class="toc-text">6.1finally块中的代码什么时候被执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2异常处理的原理是什么"><span class="toc-number">0.2.</span> <span class="toc-text">6.2异常处理的原理是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3运行时异常和普通异常有什么区別"><span class="toc-number">0.3.</span> <span class="toc-text">6.3运行时异常和普通异常有什么区別</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-输入输出流"><span class="toc-number"></span> <span class="toc-text">7.输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1Java-IO-流的实现机制是什么"><span class="toc-number">0.1.</span> <span class="toc-text">7.1Java  IO 流的实现机制是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2管理文件和目法的类是什么"><span class="toc-number">0.2.</span> <span class="toc-text">7.2管理文件和目法的类是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-Java-Socket-是什么"><span class="toc-number">0.3.</span> <span class="toc-text">7.3 Java  Socket 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-什么是Java序列化"><span class="toc-number">0.4.</span> <span class="toc-text">7.4 什么是Java序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Java平台与内存管理"><span class="toc-number"></span> <span class="toc-text">8.Java平台与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-JVM加载class文件的原理是什么"><span class="toc-number">0.1.</span> <span class="toc-text">8.2 JVM加载class文件的原理是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3什么是GC"><span class="toc-number">0.2.</span> <span class="toc-text">8.3什么是GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4Java是否存在内存泄露问题"><span class="toc-number">0.3.</span> <span class="toc-text">8.4Java是否存在内存泄露问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5Java中的堆和栈有什么区别"><span class="toc-number">0.4.</span> <span class="toc-text">8.5Java中的堆和栈有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-容器"><span class="toc-number"></span> <span class="toc-text">9.容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1Java-Collections框架是什么"><span class="toc-number">0.1.</span> <span class="toc-text">9.1Java Collections框架是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-什么是迭代器"><span class="toc-number">0.2.</span> <span class="toc-text">9.2 什么是迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3ArrayList，Vector和LinkedList有什么区别"><span class="toc-number">0.3.</span> <span class="toc-text">9.3ArrayList，Vector和LinkedList有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4HashMap、HashTable、-TreeMap和WeakHashMap哪些区別"><span class="toc-number">0.4.</span> <span class="toc-text">9.4HashMap、HashTable、  TreeMap和WeakHashMap哪些区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5用自定义类作为HashMap或HashTable的key需要注意哪些问题"><span class="toc-number">0.5.</span> <span class="toc-text">9.5用自定义类作为HashMap或HashTable的key需要注意哪些问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-Collection和-Collections有什么区别"><span class="toc-number">0.6.</span> <span class="toc-text">9.6 Collection和 Collections有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-多线程"><span class="toc-number"></span> <span class="toc-text">10.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-什么是线程？它与进程有什么区别？为什么要使用多线程"><span class="toc-number">0.1.</span> <span class="toc-text">10.1 什么是线程？它与进程有什么区别？为什么要使用多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-同步和异步有什么区别"><span class="toc-number">0.2.</span> <span class="toc-text">10.2 同步和异步有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-如何实现Java多线程"><span class="toc-number">0.3.</span> <span class="toc-text">10.3 如何实现Java多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-run-方法与start-方法有什么区別"><span class="toc-number">0.4.</span> <span class="toc-text">10.4 run()方法与start()方法有什么区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5多线程同步的实现方法有哪些"><span class="toc-number">0.5.</span> <span class="toc-text">10.5多线程同步的实现方法有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6sleep-方法与wait-方法有什么区別"><span class="toc-number">0.6.</span> <span class="toc-text">10.6sleep()方法与wait()方法有什么区別</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7终止线程的方法有哪些"><span class="toc-number">0.7.</span> <span class="toc-text">10.7终止线程的方法有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8synchronized-与Lock-有什么区别"><span class="toc-number">0.8.</span> <span class="toc-text">10.8synchronized 与Lock 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-9什么是守护线程"><span class="toc-number">0.9.</span> <span class="toc-text">10.9什么是守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-10join-方法的作用是什么"><span class="toc-number">0.10.</span> <span class="toc-text">10.10join()方法的作用是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Java数据库操作"><span class="toc-number"></span> <span class="toc-text">11. Java数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1如何通过JDBC连接数据庫"><span class="toc-number">0.1.</span> <span class="toc-text">11.1如何通过JDBC连接数据庫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2JDBC处理事务采取什么方法"><span class="toc-number">0.2.</span> <span class="toc-text">11.2JDBC处理事务采取什么方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3Class-forName的作用是什么"><span class="toc-number">0.3.</span> <span class="toc-text">11.3Class.forName的作用是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4Statement-PreparedStatement和CallableStatement有什么区别"><span class="toc-number">0.4.</span> <span class="toc-text">11.4Statement,PreparedStatement和CallableStatement有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5getString-方法和getObject-方法有什么区别"><span class="toc-number">0.5.</span> <span class="toc-text">11.5getString()方法和getObject()方法有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6什么是JDO"><span class="toc-number">0.6.</span> <span class="toc-text">11.6什么是JDO</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">阿鱼的碎碎念</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">java程序员--java基础知识篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-03-23 15:56:03"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2019-03-23</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-16 17:43:23"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-16</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">31.1k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 109 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="第一步，慢慢来"><a href="#第一步，慢慢来" class="headerlink" title="第一步，慢慢来"></a><center>第一步，慢慢来</center></h3><center>![java logo](/assets/blogImg/java%20logo.png)</center>

<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h4 id="1-1为什么需要public-static-void-mian-String-args-这个方法"><a href="#1-1为什么需要public-static-void-mian-String-args-这个方法" class="headerlink" title="1.1为什么需要public static void mian(String[] args)这个方法"></a>1.1为什么需要public static void mian(String[] args)这个方法</h4><p>该方法为java程序的入口方法，jvm运行时会首先找main()方法。按照必须有public 与static修饰，返回值为void且方法的参数为字符串数组来查找方法的入口地址。</p>
<a id="more"></a>
<p>1) 由于public与static没有先后顺序关系，因此下面的定义也是合理的。<br>static  public  void  main  (String[ ] args)<br>2) 也可以把main()方法定义为final。<br>public  static  final  void  main  (String[ ] args)<br>3) 也可以用synchronized来修饰main()方法。<br>static  public  synchronized  void  main  ( String[ ] args)</p>
<p>不管哪种定义方式，都必须保证main()方法的返回值为void，并有static与public关键字 修饰。同时由于main()方法为程序的人口方法，因此不能甩abstract关键字来修饰。<br>提问：同一个.java文件中是否可以有多个main()方法？<br>虽然每个类中都可以定义main()方法，但是只有与文件名相同的用public修饰的类中的main()方法才能作为整个程序的入口方法。</p>
<p>例题：Java程序中程序运行人口方法main的签名正确的有（        ）。<br>A. public  static  void  main  (String[ ] args)<br>B.  public  static  final  void  main  (String[ ] args)<br>C. static  public  void  main  (String[ ] args)<br>D. static  public  synchronized  void  main  (String[ ] args)<br>E. static  public  abstract  void  main  (String[ ] args)<br>答案：A、B、C、D。</p>
<h4 id="1-2如何实现在main-方法执行前输出“Hello-world”"><a href="#1-2如何实现在main-方法执行前输出“Hello-world”" class="headerlink" title="1.2如何实现在main()方法执行前输出“Hello world”?"></a>1.2如何实现在main()方法执行前输出“Hello world”?</h4><p>在Java语言中，由于静态块在类被加载时就会被调用，因此可以在main ()方法执行前，利用静态块实现输出“Hello  World”的功能.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public class Test &#123;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;静态块中的Hello world!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		System.out.println(&quot;在main方法中&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为:<br>静态块中的Hello world!<br>在main方法中<br>由于静态块不管顺序如何，都会在main()方法执行之前执行。所以下面代码输出相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		System.out.println(&quot;在main方法中&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;静态块中的Hello world!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3Java程序初始化的顺序是怎样的"><a href="#1-3Java程序初始化的顺序是怎样的" class="headerlink" title="1.3Java程序初始化的顺序是怎样的"></a>1.3Java程序初始化的顺序是怎样的</h4><p>当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有 当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。<br>Java程序的初始化一般遵循3个原则（优先级依次递减）：<br>①静态对象（变量）优先于非静态对象（变量）初始化，其中，静态对象（变量）只初始化一次，而非静态对象（变量） 可能会初始化多次。<br>②父类优先于子类进行初始化。<br>③按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化。</p>
<p>Java程序初始化工作可以在许多不同的代码块中来完成（例如静态代码块、构造函数 等），它们执行的顺序如下：<strong>父类静态变量&gt;父类静态代码块&gt;子类静态变量&gt;子类静态代码块&gt;父类非静态变量&gt;父类非静态代码块&gt;父类构造函数&gt;子类非静态变量&gt;子类非静态代码块&gt;子类构造函数</strong>。<br>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	class Base &#123;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;Base static block!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;Base block!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Base() &#123;</span><br><span class="line">		System.out.println(&quot;Base constructor!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	public class Second extends Base&#123;</span><br><span class="line">		static &#123;</span><br><span class="line">			System.out.println(&quot;Second static block!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;Second block!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public Second() &#123;</span><br><span class="line">			System.out.println(&quot;Second constructor!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public static void main(String[] args) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">			new Second();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>Base static block!<br>Second static block!<br>Base block!<br>Base constructor!<br>Second block!<br>Second constructor!</p>
<h4 id="1-4Java中的作用域有哪些"><a href="#1-4Java中的作用域有哪些" class="headerlink" title="1.4Java中的作用域有哪些"></a>1.4Java中的作用域有哪些</h4><p>在Java语言中，作用域是由花括号的位置决定的，它决定了其定义的变量名的可见性与 生命周期。<br>变量的类型主要有3种：成员变量、静态变量和局部变量。成员变量也有4种作用域。</p>
<table>
<thead>
<tr>
<th align="center">作用域和可见性</th>
<th align="center">当前类</th>
<th align="center">同一包下</th>
<th align="center">子类</th>
<th align="center">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">v</td>
<td align="center">v</td>
<td align="center">v</td>
<td align="center">v</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">v</td>
<td align="center">v</td>
<td align="center">v</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">defaoult</td>
<td align="center">v</td>
<td align="center">v</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">v</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
</tbody></table>
<p>需要注意的是，这些修饰符只能修饰成员变量，不能用来修饰局部变量。private与protec­ted 不能用来修饰类（只有public、abstract或final能用来修饰类）。<br>例题：<br>下列说法中，正确的是（     ）<br>A.实例方法可直接调用超类的实例方法         B.实例方法可直接调用超类的类方法<br>C.实例方法可直接调用其他类的实例方法      D.实例方法可直接调用本类的类方法</p>
<p>答案：D。当超类的实例方法或类方法为private时，是不能被子类调用的。同理，当其他类的实例方法为private时，也不能被直接调用。</p>
<h4 id="1-5一个Java文件中是否可以定义多个类"><a href="#1-5一个Java文件中是否可以定义多个类" class="headerlink" title="1.5一个Java文件中是否可以定义多个类"></a>1.5一个Java文件中是否可以定义多个类</h4><p>一个Java文件中可以定义多个类，但是最多只能有一个类被public修饰，并且这个类的类名与文件名必须相同，若这个文件中没有public的类，则文件名随便是一个类的名字即可。</p>
<h4 id="1-6什么是构造闲数"><a href="#1-6什么是构造闲数" class="headerlink" title="1.6什么是构造闲数"></a>1.6什么是构造闲数</h4><p>构造函数是一种特殊的函数，用来在对象实例化时初始化对象的成员变量。在Java语言中，构造函数具有以下特点。</p>
<p>1) 构造函数必须与类的名字相同，并且不能有返回值（返回值也不能为void)<br>2) 每个类可以有多个构造函数。会有一个默认的无参构造函数<br>3) 构造函数可以有0个、1个或1个以上的参数。<br>4) 构造函数总是伴随着new操作一起调用，且不能由程序的编写者直接调用，必须要由系统调用。<br>5)构造函数的主要作用是完成对象的初始化工作。<br>6) 构造函数不能被继承，因此，它不能被覆盖，但是构造函数能够被重载，可以使用不同的参数个数或参数类型来定义多个构造函数。<br>7) 子类可以通过super关键字来显式地调用父类的构造函数，当父类没有提供无参数的构造函数时，子类的构造函数中必须显式地调用父类的构造函数。<br>8) 当父类和子类都没有定义构造函数时，编译器会为父类生成一个默认的无参数的构造函数，给子类也生成一个默认的无参数的构造函数。此外，默认构造器的修饰符只跟当前类的修饰符有关（例如，如果一个类被定义为public，那么它的构造函数也是public)。</p>
<p>问：普通方法是否可以与构造函数有相同的方法名？<br>可以。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public Test() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的构造函数存根</span><br><span class="line">		System.out.println(&quot;Construct!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void Test() &#123;</span><br><span class="line">		System.out.println(&quot;call Test&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Test a &#x3D; new Test();</span><br><span class="line">		a.Test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>Construct!<br>call Test</p>
<p>常见笔试题： </p>
<ol>
<li>下列关于构造方法的叙述中，错误的是（      ）。<br>A. Java语言规定构造方法名与类名必须相同<br>B. Java语言规定构造方法没有返回值，但不用void声明<br>C. Java语言规定构造方法不可以重载<br>D. Java语言规定构造方法只能通过new自动调用<br>答案：C。可以定义多个构造函数，只要不同的构造函数有不同的参数即可。 </li>
<li>下列说法中，正确的是（     )<br>A. class中的constructor不可省略<br>B. constructor必须与class同名，但方法不能与class同名<br>C. constructor在一个对象被new时执行<br>D. 一个class 只能定义一个 constructor<br>答案：C</li>
</ol>
<h4 id="1-7为什么Java中有些接口没有任何方法"><a href="#1-7为什么Java中有些接口没有任何方法" class="headerlink" title="1.7为什么Java中有些接口没有任何方法"></a>1.7为什么Java中有些接口没有任何方法</h4><p>Java不支持多重继承，即一个类只能有一个父类，为了克服单继承的缺点，Java语言引人了接口这一概念。接口是抽象方法定义的集合（接口中也可以定义一些常量值），是一 种特殊的抽象类。<br>接口中只包含方法的定义，没有方法的实现。接口中的所有方法都是抽象的。接口中成员的作用域修饰符都是public,接口中的常量值默认使用public static final修饰。 一个类可以实现多个接口,间接实现多继承。<br>有些接口内部没有声明任何方法，也就是说，实现这些接口的类不需要重写任何方法，这些没有任何方法声明的接口又被叫做<strong>标识接口**</strong>，标识接口对实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用，用来表明实现它的类属于一个特定的类型。Java类库中已存在的标识接口有Cloneable和Serializable等。</p>
<p>例题：<br>不能用来修饰interface的有（       ）<br>A. private   B. public   C.protected   D.static<br>答案：A、C、D。</p>
<h4 id="1-8Java中的clone方法有什么作用"><a href="#1-8Java中的clone方法有什么作用" class="headerlink" title="1.8Java中的clone方法有什么作用"></a>1.8Java中的clone方法有什么作用</h4><p>Java中的所有类默认都继承自Object类，而Object类中提供了一个clone()方法。这个方法的作用是返回一个Object对象的复制。这个复制函数返回的是一个新的对象而不是一个引用。以下是使用clone()方法的步骤。</p>
<p>1) 实现clone的类首先需要继承Cloneable接口。Cloneable接口实质上是一个标识接口， 没有任何接口方法。<br>2)在类中重写Object类中的clone()方法。<br>3)在clone方法中调用super.clone()无论clone类的继承结构是什么，super. clone()都 会直接或间接调用java. lang. Object类的clone()方法。<br>4)把浅复制的引用指向原型对象新的克隆体。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Object implements Cloneable&#123;</span><br><span class="line">	private int aInt &#x3D; 0;</span><br><span class="line">	public int getInt() &#123;</span><br><span class="line">		return aInt;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setInt() &#123;</span><br><span class="line">		aInt &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void changeInt() &#123;</span><br><span class="line">		this.aInt &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Object clone() &#123;</span><br><span class="line">		Object o &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			o &#x3D; (Object)super.clone();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return o;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestRef &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Object a &#x3D; new Object();</span><br><span class="line">		Object b &#x3D; a.clone();</span><br><span class="line">		b.changeInt();</span><br><span class="line">		System.out.println(&quot;a:&quot;+a.getInt());</span><br><span class="line">		System.out.println(&quot;b:&quot;+b.getInt());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>a:0<br>b:1</p>
<p>在C++语言中，当开发人员自定义复制构造函数时，会存在浅复制与深复制之分。 Java 语言在重载clone()方法时也存在同样的问题，当类中只有一些基本的数据类型时，采用上述方法就可以了，但是当类中包含了一些对象时，就需要用到深复制了，实现方法是在对对象调用clone ()方法完成复制后，接着对对象中的非基本类型的属性也调clone()方法完成深复制。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java. util. Date;</span><br><span class="line">class Object implements Cloneable&#123;</span><br><span class="line">	private Date birth &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">	public Date getBirth() &#123;</span><br><span class="line">		return birth;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	public void setBirth(Date birth) &#123;</span><br><span class="line">		this.birth &#x3D; birth;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void changeDate() &#123;</span><br><span class="line">		this.birth.setMonth(4);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Object clone() &#123;</span><br><span class="line">		Object o &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			o &#x3D; (Object) super.clone();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;实现深复制</span><br><span class="line">		o.birth &#x3D; (Date)this.getBirth().clone();</span><br><span class="line">		return o;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	public class TestRef&#123;</span><br><span class="line">		</span><br><span class="line">	public static void main(String[ ] args) &#123;</span><br><span class="line">		Object a &#x3D; new Object();</span><br><span class="line">		Object b &#x3D; a.clone();</span><br><span class="line">		b.changeDate();</span><br><span class="line">		System.out.println(&quot;a:&quot;+a.getBirth());</span><br><span class="line">		System.out.println(&quot;b:&quot;+b.getBirth());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>a:Sat Mar 23 21:52:40 CST 2019<br>b:Thu May 23 21:52:40 CST 2019</p>
<p>总结：使用时，检查类有无非基本类型（即对象） 的数据成员。若没有，则返回super. clone()即可；若有，确保类中包含的所有非基本类型的成员变量都实现了深复制。<br>Object  o = super, clone( ) ； //先执行浅复制<br>对每一个对象attr执行以下语句：<br>o. attr = this. getAttr( ). clone  ()；<br>最后返回o。<br>引申：浅复制和深复制有什么区别？<br>浅复制（ Shallow Clone):被复制对象的所有变量都含有与原来对象相同的值，而所有对 其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所 引用的对象。<br>深复制（  Deep  Clone):被复制对象的所有变量 都含有与原来对象相同的值，除去那些引用其他对 象的变量。那些引用其他对象的变量将指向被复制 的新对象，而不再是原有的那些被引用的对象。换言之，深复制把复制的对象所引用的对象都复制了一遍。</p>
<p>对下列类进行复制图解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">  public int i; </span><br><span class="line">  public StringBuffer s； </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/assets/blogImg/clone.png" alt="clone"></p>
<h4 id="1-9什么是反射机制"><a href="#1-9什么是反射机制" class="headerlink" title="1.9什么是反射机制"></a>1.9什么是反射机制</h4><p>反射机制提供的功能主要有：得到一个对象所属的类；获取一个类的所有成员<br>变量和方法；在运行时创建对象；在运行时调用对象的方法。 其实，反射机制非常重要的一个作用就是可以在运行时动态地创建类的对象。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">	public void f() &#123;</span><br><span class="line">		System.out.println(&quot;Base!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Base&#123;</span><br><span class="line">	public void f() &#123;</span><br><span class="line">		System.out.println(&quot;Sub&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Reflect &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;使用反射机制加载类</span><br><span class="line">			Class c &#x3D; Class.forName(&quot;Sub&quot;);</span><br><span class="line">			Base b &#x3D;(Base) c.newInstance(); </span><br><span class="line">			b.f();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>Sub</p>
<p>在反射机制中，class是一个非常重要的类，那么如何才能获取class类呢？总共有如下3 种方法可以获取到class类： </p>
<p>1) class. forName  (“类的路径”），如上例所示。<br>2) 类名.class<br>3) 实例.getClass( )</p>
<p>例题：Java创建对象的方式有几种？<br>答案：共有4种创建对象的方法。<br>1 )通过new语句实例化一个对象。<br>2) 通过反射机制创建对象。<br>3) 通过clone()方法创建一个对象。<br>4) 通过反序列化的方式创建对象。</p>
<h4 id="1-10package有什么作用"><a href="#1-10package有什么作用" class="headerlink" title="1.10package有什么作用"></a>1.10package有什么作用</h4><p>package主要有以下两个作用：<br>第一，提供多层命名空间，解决命名冲突，通 过使用package,使得处于不同package中的类可以存在相同的名字。<br>第二，对类按功能进行 分类，使项目的组织更加清晰。当幵发一个有非常多的类的项目时，如果不使用package对类 进行分类，而是把所有类都放在一个package下，这样的代码不仅可读性差，而且可维护性也 不好，会严重影响开发效率。</p>
<p>常见笔试题：<br>下列说法中，正确的是（     ）。<br>A. Java中包的主要作用是实现跨平台功能<br>B. package语句只能放在import语句后面<br>C.包(package)由一组类（class)和接口（interface)组成<br>D.可以用#indude关键字来表明来自其他包中的类<br>答案：C。D应该为import</p>
<h4 id="1-11如何实现类似C语言中函数指针的功能"><a href="#1-11如何实现类似C语言中函数指针的功能" class="headerlink" title="1.11如何实现类似C语言中函数指针的功能"></a>1.11如何实现类似C语言中函数指针的功能</h4><p>在C语言中，有一个非常重要的概念——函数指针，其最重要的功能是实现回调函数。所谓回调函数，就是指函数先在某处注册，而它将在稍后某个需要的时候 被调用。回调函数一般用于截获消息、获取系统信息或处理异步事件。<br>函数指针一般作为函数的参数来使用，开发人员在使用时可以根据自己的需求传递自定义的函数来实现指定的功能，例如，在实现排序算法时，可以通过传递一个函数指针来决定两个数的先后顺序，从而最终决定该算法是按升序还是降序排列<br>在Java语言中没有指针的概念，可以利用接口与类来实现同样的效果。<br>具体实现如下：<br>先定义一个接口，然后在接口中声明 要调用的方法，接着实现这个接口，最后把这个实现类的一个对象作为参数传递给调用程序， 调用程序通过这个参数来调用指定的函数，从而实现回调函数的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IntCompare&#123;</span><br><span class="line">	public int cmp(int a,int b) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cmp1 implements IntCompare&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int cmp(int a, int b) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		if (a&gt;b) </span><br><span class="line">			return 1;</span><br><span class="line">		else if (a&lt;b) </span><br><span class="line">			return -1;</span><br><span class="line">		else</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cmp2 implements IntCompare&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int cmp(int a, int b) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		if (a&gt;b) </span><br><span class="line">			return -1;</span><br><span class="line">		else if (a&lt;b) </span><br><span class="line">			return 1;</span><br><span class="line">		else</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public class Compare &#123;</span><br><span class="line"></span><br><span class="line">	public static void insertSort(int[]a,IntCompare cmp) &#123;</span><br><span class="line">		if(a!&#x3D;null) &#123;</span><br><span class="line">			for(int i &#x3D; 1;i&lt;a.length;i++) &#123;</span><br><span class="line">				int temp &#x3D; a[i];</span><br><span class="line">				int j &#x3D; i;</span><br><span class="line">				if(cmp.cmp(a[j-1], temp)&#x3D;&#x3D;1) &#123;</span><br><span class="line">					while(j&gt;&#x3D;1&amp;&amp;cmp.cmp(a[j-1], temp)&#x3D;&#x3D;1) &#123;</span><br><span class="line">						a[j]&#x3D;a[j-1];</span><br><span class="line">						j--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				a[j]&#x3D;temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int[]array1 &#x3D; &#123;7,3,19,40,4,7,1&#125;;</span><br><span class="line">		insertSort(array1, new Cmp1());</span><br><span class="line">		System.out.println(&quot;升序排序&quot;);</span><br><span class="line">		for(int i&#x3D;0;i&lt;array1.length;i++) &#123;</span><br><span class="line">			System.out.print(array1[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		int[]array2 &#x3D; &#123;7,3,19,40,4,7,1&#125;;</span><br><span class="line">		insertSort(array2, new Cmp2());</span><br><span class="line">		System.out.println(&quot;降序排序&quot;);</span><br><span class="line">		for(int i&#x3D;0;i&lt;array2.length;i++) &#123;</span><br><span class="line">			System.out.print(array2[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：<br>升序排序<br>1 3 4 7 7 19 40<br>降序排序<br>40 19 7 7 4 3 1<br>上例定义了一个用来比较大小的接口 IntCompare,这个接口实际上充当了 C语言中函数指 针的功能，在使用时，开发人员可以根据实际需求传入自定义的类。在上例中分别有两个类 Cmpl和CmP 2都实现了这个接口，分别用来在实现升序排序和降序排序时使用。</p>
<h2 id="2-面向对象技术"><a href="#2-面向对象技术" class="headerlink" title="2.面向对象技术"></a>2.面向对象技术</h2><h4 id="2-1面向对象有哪些特征"><a href="#2-1面向对象有哪些特征" class="headerlink" title="2.1面向对象有哪些特征"></a>2.1面向对象有哪些特征</h4><p>面向对象的主要特征包括<strong>抽象、继承、封装和多态</strong>。</p>
<p>1) 抽象。抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当 前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：一是过程抽象；二是数据抽象。<br>2) 继承。继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确 表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了 原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且派生类可以修改或增加新的方法使之更适合特殊的需要。<br>3) 封装。封装是指将客观事物抽象成类，每个类对自身的数据和方法实行保护。类可以 把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>4) 多态。多态是指允许不同类的对象对同一消息作出响应。多态包括参数化多态和包含 多态。多态性语言具有灵活、抽象、行为共享、代码共享等优势，很好地解决了应用程序函数同名问题。</p>
<h4 id="2-2什么是继承"><a href="#2-2什么是继承" class="headerlink" title="2.2什么是继承"></a>2.2什么是继承</h4><p>通过继承，子类可以使用父类中的一些成员变 量与方法，从而能够提高代码的复用性，提高开发效率。在Java语言中，被继承的类叫基类 (superclass)或父类，继承基类或父类的类叫派生类或子类（subclass)。继承是通过extends 关键字来实现的，使用格式为：class子类名extends父类名。<br>继承主要有如下几个特性： </p>
<p>1) Java语言不支持多重继承，也就是说，子类至多只能有一个父类，但是可以通过实现 多个接口来达到多重继承的目的。<br>2) 子类只能继承父类的非私有（public与protected)成员变量与方法。<br>3) 当子类中定义的成员变量和父类中定义的成员变量同名时，子类中的成员变量会覆盖 父类的成员变量，而不会继承。<br>4) 当子类中的方法与父类中的方法有相同的函数签名（相同的方法名，相同的参数个数 与类型）时，子类将会覆盖父类的方法，而不会继承。</p>
<p>例题：<br>列有关继承的说法中，正确的是（      ）。<br>A.子类能继承父类的所有方法和状态     B.子类能继承父类的非私有方法和状态<br>C.子类只能继承父类public方法和状态 D.子类能继承父类的方法，而不是状态<br>答案：B。</p>
<h4 id="2-3组合和继承有什么区別"><a href="#2-3组合和继承有什么区別" class="headerlink" title="2.3组合和继承有什么区別"></a>2.3组合和继承有什么区別</h4><p>组合和继承是面向对象中两种代码复用的方式。组合是指在新类里面创建原有类的对象， 重复利用已有类的功能。继承是面向对象的主要特性之一，它允许设计人员根据其他类的实现 来定义一个类的实现。组合和继承都允许在新的类中设置子对象（subobject),只是组合是显式的，而继承则是隐式的。组合和继承存在着对应关系：组合中的整体类和继承中的子类对应，组合中的局部类和继承中的父类对应。</p>
<p>遵循以下两点原则。 </p>
<p>1) 除非两个类之间是“is-a”（继承）的关系，否则不要轻易地使用继承，不要单纯地为了实现代码的重用而使用继承，因为过多地使用继承会破坏代码的可维护性，当父类被修改时，会影响到所有继承自它的子类，从而增加程序的维护难度与成本。<br>2) 不要仅仅为了实现多态而使用继承，如果类之间没有“is-a”的关系，可以通过实现接口与组合的方式来达到相同的目的。设计模式中的策略模式可以很好地说明这一点，采用接口与组合的方式比采用继承的方式具有更好的可扩展性。</p>
<p>在Java语言中，能使用组合就尽量不要使用继承。</p>
<h4 id="2-4多态的实现机制是什么"><a href="#2-4多态的实现机制是什么" class="headerlink" title="2.4多态的实现机制是什么"></a>2.4多态的实现机制是什么</h4><p>多态表示当同一个操作作用在不同对象时，会有不同的语义，从而会产生不同的结果，例如，同样是执行“+”操作，“3+4” 用 来实现整数相加，而 “3” + “4” 却实现了字符串的连接。<br>多态主要有以下两种表现方式：</p>
<p>1) 方法的重载(overload)重载是指同一个类中有多个同名的方法，但这些方法有着不<br>同的参数，因此在编译时就可以确定到底调用哪个方法，它是一种编译时多态。<br>2) 方法的覆盖（override)。子类可以覆盖父类的方法，因此同样的方法会在父类与子类 中有着不同的表现形式。通过方法覆盖实现的多态也可以被称为运行时多态。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">	public Base() &#123;</span><br><span class="line">		g();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void f() &#123;</span><br><span class="line">		System.out.println(&quot;Base f()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void g() &#123;</span><br><span class="line">		System.out.println(&quot;Base g()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Der extends Base&#123;</span><br><span class="line">	public void f() &#123;</span><br><span class="line">		System.out.println(&quot;Der f()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void g() &#123;</span><br><span class="line">		System.out.println(&quot;Der g()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestPol &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Base b &#x3D; new Der();</span><br><span class="line">		b.f();</span><br><span class="line">		b.g();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Der g()<br>Der f()<br>Der g()</p>
<p>由于子类Derived的f()方法和g()方法与父类Base的方法同名，因此Derived的 方法会覆盖Base的方法。在执行Base b = new Derived()语句时，会调用Base类的构造函数， 而在Base的构造函数中，执行了 g()方法，由于Java语言的多态特性，此时会调用子类De­ rived 的 g() 方法， 而非父类Base的g()方法，因此会输出Derived g()。由于实际创建的是 Derived类的对象，后面的方法调用都会调用子类Derived的方法。<br><strong>此外，只有类中的方法才有多态的概念，类中成员变量没有多态的概念</strong><br>例题：<br>Java中提供了哪两种用于多态的机制？<br>答案：编译时多态和运行时多态。编译时多态是通过方法的重载实现的，运行时多态是通 过方法的覆盖（子类覆盖父类方法）实现的。</p>
<h4 id="2-5重载和覆盖有什么区别"><a href="#2-5重载和覆盖有什么区别" class="headerlink" title="2.5重载和覆盖有什么区别"></a>2.5重载和覆盖有什么区别</h4><p>重载与覆盖的区别主要有以下几个方面： </p>
<p>1) 覆盖是子类和父类之间的关系，是垂直关系；重载是同一个类中方法之间的关系，是 水平关系。<br>2) 覆盖只能由一个方法或只能由一对方法产生关系；重载是多个方法之间的关系。<br>3) 覆盖要求参数列表相同；重载要求参数列表不同。<br>4) 覆盖关系中，调用方法体是根据对象的类型（对象对应存储空间类型）来决定；而重 载关系是根据调用时的实参表与形参表来选择方法体的。</p>
<p>例题：如下代码的运行结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Super&#123;</span><br><span class="line">	public int f() &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubClass extends Super &#123;</span><br><span class="line">	</span><br><span class="line">	public float f() &#123;</span><br><span class="line">		return 2f;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Super s &#x3D; new Super();</span><br><span class="line">		System.out.println(s.f());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>答案：编译错误。因为函数是不能以返回值来区分的，虽然父类与子类中的函数有着不同 的返回值，但是它们有着相同的函数名，因此，编译器无法区分。<br>（注：但是我在eclipse中编译的时候会提示float类型与Super.f()不兼容，强制运行后输出的结果是Super.f()返回的1，因该是进行了某些处理。）</p>
<h4 id="2-6抽象类-abstract-class-与接口-interface-有什么异同"><a href="#2-6抽象类-abstract-class-与接口-interface-有什么异同" class="headerlink" title="2.6抽象类(abstract class)与接口 (interface)有什么异同"></a>2.6抽象类(abstract class)与接口 (interface)有什么异同</h4><p><strong>抽象类：</strong><br>(1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法</p>
<p>(2) 抽象类不能被实例化</p>
<p>(3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类</p>
<p>(4) 具体派生类必须覆盖基类的抽象方法</p>
<p>(5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们。</p>
<p><strong>接口：</strong><br>(1) 接口不能被实例化</p>
<p>(2) 接口只能包含方法声明</p>
<p>(3) 接口的成员包括方法、属性、索引器、事件</p>
<p>(4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员</p>
<p><strong>相同点：</strong><br>(1) 都可以被继承</p>
<p>(2) 都不能被实例化</p>
<p>(3) 都可以包含方法声明</p>
<p>(4) 派生类必须实现未实现的方法</p>
<p><strong>区别：</strong><br>（1）抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
<p>（2）抽象类中可以有普通成员变量，接口中没有普通成员变量（接口中成员变量只能是 <strong>public static final</strong> 类型）</p>
<p>（3）接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p>
<p>（4） 一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p>（5）接口可以被多重实现，抽象类只能被单一继承</p>
<p>（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</p>
<p><strong>简单点说，接口是一种特殊形式的抽象类，使用接口完全有可能实现与抽象类相同的操作，但一般而言，抽象类多用于在同类事物中有无法具体描述的方法的场景，所以当子类和父 类之间存在有逻辑上的层次结构时，推荐使用抽象类；而接口多用于不同类之间，定义不同类 之间的通信规则，所以当希望支持差别较大的两个或者更多对象之间的特定交互行为时，应该 使用接口。</strong></p>
<p>接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类。抽象类也可以有静态的main方法。</p>
<p>例题：<br>1.下列关于接口的定义中，正确的是（ ）<br>A. void  melhoda( ) ;B.public  double  methoda  ()；<br>C. public final double methoda( ) ； D.static  void  methoda  (double  dl  )；<br>E. protected void methoda ( double dl ) ； F. int  a；<br>G. int b = 1 ； </p>
<p>答案：A、B、G。接口中的方法只能用关键字public和abstract来修 饰，因此选项C、D、E都是错误的。接口中的属性默认都为public static final,由于属性被fi­nal 修饰，因此它是常量，常量在定义时就必须初始化，因此F是错误的。</p>
<p>2.下列说法中，正确的是（ ）。<br>A.声明抽象方法大括号可有可无  B.声明抽象方法不可写出大括号<br>C.抽象方法有方法体  D. abstract可修饰属性、方法和类 </p>
<p>答案：B。抽象方法不能有方法体，同理也就不能有大括号。abstract只能用来修饰类与方法，不能用来修饰属性。</p>
<h4 id="2-7内部类有哪些"><a href="#2-7内部类有哪些" class="headerlink" title="2.7内部类有哪些"></a>2.7内部类有哪些</h4><p>把一个类定义到另外一个类的内部，在类里面的这个类就叫做内部 类，外面的类叫做外部类。这个内部类可以被看作外部类的一个成员（与类的属性和方法类似）。还有一种类被称为顶层（top-level)类，指的是类定义代码不嵌套在其 他类定义中的类。</p>
<p>内部类可以分为很多种，主要有以下4种：<strong>静态内部类（ static inner class)、成员内部类（ member inner class)、局部内部类（ local inner class) 和匿名内部类（ anonymous inner class)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class outerClass&#123;</span><br><span class="line">	static class innerClass&#123;&#125; &#x2F;&#x2F;静态内部类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class outerClass&#123;</span><br><span class="line">	class innerClass&#123;&#125;&#x2F;&#x2F;成员内部类（普通内部类）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class outerClass&#123;</span><br><span class="line">	public void menberFunction() &#123;</span><br><span class="line">		class innerClass&#123;&#125; &#x2F;&#x2F;局部内部类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyFrame extends Frame&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public MyFrame() &#123;</span><br><span class="line">		addWindowListener(new WindowAdapter() &#123;&#x2F;&#x2F;匿名内部类</span><br><span class="line">			public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">				dispose();</span><br><span class="line">				System.exit(0);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）静态内部类是指被声明为static的内部类，它可以不依赖于外部类实例而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，<strong>不能访问外部类的普通成员变量</strong>，只能访问外部类中的静态成员和静态方法（包括私有类型）。<br>2）一个静态内部类，如果去掉“static”关键字，就成为成员内部类。成员内部类为非静 态内部类，它可以自由地引用外部类的属性和方法，无论这些属性和方法是静态的还是非 静态的。但是它与一个实例绑定在了一起，不可以定义静态的属性和方法。只有在外部的 类被实例化后，这个内部类才能被实例化。需要注意的是，<strong>非静态内部类中不能有静态成员。</strong><br>3）局部内部类指的是定义在一个代码块内的类，它的作用范围为其所在的代码块，是内部类 中最少使用到的一种类型。局部内部类像局部变量一样，不能被public，protected、private以 及static修饰，只能访问方法中定义为final类型的局部变量。<br>4）匿名内部类是一种没有类名的内部类，不使用关键字class、extends、implements,没有构造函数，它必须继承（extends)其他类或实现其他接口。匿名内部类的好处是代码更加简洁、 紧凑，但带来的问题是易读性下降。在使用匿名内部类时，需要牢记以下几个原则： </p>
<p>1) 匿名内部类不能有构造函数。<br>2) 匿名内部类不能定义静态成员、方法和类。<br>3) 匿名内部类不能是 public、protected、private、static。<br>4) 只能创建匿名内部类的一个实例。<br>5) 一个匿名内部类一定是在new的后面，这个匿名类必须继承一个父类或实现一个 接口。<br>6) 因为匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</p>
<h4 id="2-8如何获取父类的类名"><a href="#2-8如何获取父类的类名" class="headerlink" title="2.8如何获取父类的类名"></a>2.8如何获取父类的类名</h4><p>Java语言提供了获取类名的方法：getClass( ). getName()<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class getClassName &#123;</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		System.out.println(this.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		new getClassName().test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：getClassName</p>
<p>但是不能直接通过调用父类的getClass( ). getName ()<br>（super. getClass( ). getName ()）方法来获取父类的类名，主要原因在于Java语言中任何类都继承自Object类，getClass()方法在Object类中被定义为final与native,子类不能覆盖该方法。因此 this. getClass()和 super. getClass()最终都调用的是Object 中的 getClass()方法。</p>
<p>可以通过Java的反射机制，使用getClass( ). getSuperclass( ). getName(）<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Super&#123;</span><br><span class="line">&#125;</span><br><span class="line">public class getClassName extends Super&#123;</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		System.out.println(this.getClass().getSuperclass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		new getClassName().test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：Super</p>
<h4 id="2-9-this与super有什么区別"><a href="#2-9-this与super有什么区別" class="headerlink" title="2.9 this与super有什么区別"></a>2.9 this与super有什么区別</h4><p>this用来指向当前实例对象，它的一个重要的作用就是用来区分对象的成员变量与方法的形参（当一个方法的形参与成员变量的名字相同时，就会覆盖成员变量）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Super&#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;正确的写法</span><br><span class="line">	public Super(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;错误的写法</span><br><span class="line">	public Super(String name) &#123;</span><br><span class="line">		name &#x3D;name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super可以用来访问父类的方法或成员变量。当子类的方法或成员变量与父类有相同名字 时也会覆盖父类的方法或成员变量，要想访问父类的方法或成员变量只能通过super关键字来访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class basef&#123;</span><br><span class="line">	public void f() &#123;</span><br><span class="line">		System.out.println(&quot;base:f()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends basef&#123;</span><br><span class="line">	public void f() &#123;</span><br><span class="line">		System.out.println(&quot;sub:f()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void subf() &#123;</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">	public void basef() &#123;</span><br><span class="line">		super.f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestSuper &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Sub s &#x3D; new Sub();</span><br><span class="line">		s.subf();</span><br><span class="line">		s.basef();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>sub:f()<br>base:f()</p>
<p>例题：下面的运行结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">	public Base()&#123;</span><br><span class="line">		System.out.println(&quot;Base!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Base&#123;</span><br><span class="line">	public Sub() &#123;</span><br><span class="line">		System.out.println(&quot;Sub!&quot;);</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class TestSuper &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Base b &#x3D; new Sub();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：编译错误。当子类构造函数需要显示调用父类构造函数时，super（）必须为构造函数中的第一句语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Sub() &#123;</span><br><span class="line">	super();</span><br><span class="line">	System.out.println(&quot;Sub!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改后输出结果为：<br>Base!<br>Sub!</p>
<h2 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h2><p>####3.1 变量命名有哪些规则</p>
<p>在Java语言中，变量名、函数名、数组名统称为标识符，Java语言规定标识符只能由<strong>字母（ a z ， A Z )、数字（0 9)、下画线(_)和$组成</strong>，并且标识符的<strong>第一个字符必须是字母、下画线或$</strong>。此外，标识符也不能包含空白字符（换行符、空格和制表符）。在Java语言中，变量名是区分大小写的，例如Count与count被认为是两 个不同的标识符，而非相同的标识符。</p>
<p>例题：<br>1.下列不属于Java标识符的是（  ）。<br>A. _HelloWorld  B. 3Hello World<br>C. $HelloWorld  D. HeUoWorld3<br>答案：B。</p>
<p>2.下列标识符不合法的有（ ）。<br>A. new  B. $usdollars<br>C. 1234 D. car.taxi<br>答案：A、C、D。</p>
<h4 id="3-2-break，continue以及return有什么区別"><a href="#3-2-break，continue以及return有什么区別" class="headerlink" title="3.2 break，continue以及return有什么区別"></a>3.2 break，continue以及return有什么区別</h4><p>1) break用于直接强行跳出当前循环，不再执行剩余代码。当多层循环嵌套，并且break语句出现在嵌套循环中的内层循环时，它将仅仅只是终止了内层循环的执行，而不影响外层循环的执行。<br>2) continue用于停止当次循环，回到循环起始处，进入下一次循环操作。简单来说，continue只是中断一次循环的执行而已。<br>3) return语句是一个跳转语句，用来表示从一个方法返回（返回一个值或其他复杂类 型），可以使程序控制返回到调用该方法的地方。</p>
<p>问：break如何跳出多重循环？<br>可以在多重循环的外面定义一个标识，然后在循环体里使用带有标识的break语句，这样即可跳出多重循环。Java中的标签就是一个紧跟着“：”的标识符,java语言的标签必须放在循环前面才有作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Break &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		out:</span><br><span class="line">		for(int i&#x3D;0;i&lt;5;i++) &#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;5;j++) &#123;</span><br><span class="line">				if(j&gt;&#x3D;2)</span><br><span class="line">					break out;</span><br><span class="line">				</span><br><span class="line">				System.out.println(j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;break!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<br>0<br>1<br>break!<br>当内部循环执行到j等于2时，程序跳出双重循环，执行System, out.println(“ break”)语句。</p>
<h4 id="3-3-final，finally和finalize有什么区別"><a href="#3-3-final，finally和finalize有什么区別" class="headerlink" title="3.3 final，finally和finalize有什么区別"></a>3.3 final，finally和finalize有什么区別</h4><p>1) final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承 (不能再派生出新的子类）。<br>final属性:final指的是引用的不可变性，即它只能指向初始时指向的那个对象，而不关心指向对象内容的变化。被final修饰的变量必须被初始化。<br>final方法：当一个方:法声明为final时，该方法不允许f任何子类重写这个方法，但子类仍 然可以使用这个方法。<br>final参数：用来表示这个参数在这个函数内部不允许被修改。<br>final类：当一个类被声明为fmal时，此类不能被继承，所有方法都不能被重写。一个类不能既被声明为abstract，又被声明为final。</p>
<p>2) finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块， 表示这段语句最终一定被执行。</p>
<p>3) finalize是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件等。</p>
<p>例题：JDK中哪些类是不能继承的？<br>答案：不能继承的类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在JDK中， String、SlringBuffer等都是基本类型，所以，String、StringBuffer等类是不能继承的。</p>
<h4 id="3-4-assert存什么作用"><a href="#3-4-assert存什么作用" class="headerlink" title="3.4 assert存什么作用"></a>3.4 assert存什么作用</h4><p>断言（assert)作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制， 目前很多开发语言都支持这种机制。它的主要作用是对一个boolean表达式进行检査，一个正确运行的程序必须保证这个boolean表达式的值为true，若boolean表达式的值为false，则说明 程序已经处于一种不正确的状态下，系统需要提供告警信息并且退出程序。<br>assert 包括两种表达式，分别为 assert  expression  1 与 assert  expression  1 : expression2，其中， expression1表示一个boolean表达式，expression2表示一个基本类型或者是一个对象，基本类 型包括boolean、char、double、float、  int和long。</p>
<p>assert的应用范围很多，主要包括<strong>①检査控制流；②检查输入参数是否有效；③检查函 数结果是否有效；④检查程序不变量。</strong></p>
<h4 id="3-5-static关键字有哪些作用"><a href="#3-5-static关键字有哪些作用" class="headerlink" title="3.5 static关键字有哪些作用"></a>3.5 static关键字有哪些作用</h4><p>static关键字主要有两种作用：<br>第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。<br>第二，实现某个方法或属性与类而不是对象关联在一起，在不创建对象的情况下就可以通过类来直接调用方法或使用类的属性。<br><strong>在Java语 言中，static主要有4种使用情况：成员变量、成员方法、代码块和内部类。</strong></p>
<p>java通过static关键字来达到全局的效果,Java类提供了两种类型的变量：用static关键字修饰的静态变量和不用static关键字修饰的实例变量。<br>静态变量属于类，在内存中只有一个复制（所有实例都指向同一个内存地址），对静态变量的引用有两种方式，分别为<strong>“类.静态变量”和“对象.静态变量”</strong>。<br>实例变量属于对象，只有对象被创建后，实例变量才会被分配空间，才能被使用，它在内存中存在多个复制。只能用“对象.实例变量”的方式来引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestAttribute &#123;</span><br><span class="line">	</span><br><span class="line">	public static int staticInt &#x3D; 0;</span><br><span class="line">	public int nonstaticInt &#x3D; 0;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		TestAttribute t &#x3D; new TestAttribute();</span><br><span class="line">		System.out.println(&quot;t.staticInt:&quot;+ t.staticInt);</span><br><span class="line">		System.out.println(&quot;TestAttribute.staticInt:&quot;+ TestAttribute.staticInt);</span><br><span class="line">		System.out.println(&quot;t.nonStaticInt:&quot;+ t.nonstaticInt);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;对变量都加1&quot;);</span><br><span class="line">		t.staticInt++;</span><br><span class="line">		t.nonstaticInt++;</span><br><span class="line">		</span><br><span class="line">		TestAttribute t2 &#x3D; new TestAttribute();</span><br><span class="line">		System.out.println(&quot;t2.staticInt:&quot;+ t2.staticInt);</span><br><span class="line">		System.out.println(&quot;TestAttribute.staticInt:&quot;+ TestAttribute.staticInt);</span><br><span class="line">		System.out.println(&quot;t2.nonStaticInt:&quot;+ t2.nonstaticInt);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>t.staticInt:0<br>TestAttribute.staticInt:0<br>t.nonStaticInt:0<br>对变量都加1<br>t2.staticInt:1<br>TestAttribute.staticInt:1<br>t2.nonStaticInt:0</p>
<p>(2) static成员方法<br>static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。<br>static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的 变量。<br><strong>static一个很重要的用途是实现单例模式。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	private static Singleton instance &#x3D; null;</span><br><span class="line">	</span><br><span class="line">	private Singleton() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if(instance&#x3D;&#x3D;null) &#123;</span><br><span class="line">			instance &#x3D; new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) static代码块<br>static代码块（静态代码块）在类中是独立于成员变量和成员函数的代码块的。它不在任 何一个方法体内，JVM在加载类时会执行static代码块，如果有多个static代码块，JVM将会按顺序来执行。static代码块经常被用来初始化静态变量。这些static代码块只会被执行一次。</p>
<p>(4) static内部类<br>static内部类是指被声明为static的内部类，它可以不依赖于外部类实例对象而被实例化， 而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字， 不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法。</p>
<p>引申：<br>1.什么是实例变量？什么是局部变量？什么是类变量？什么是final变量？<br>实例变量：变量归对象所有（只有在实例化对象后才可以）。每当实例化一个对象时，会创建一个副本并初始化，如果没有显示初始化，那么会初始化一个默认值。各个对象中的实例变量互不影响。<br>局部变量：在方法中定义的变量，在使用前必须初始化。<br>类变量：用static可修饰的属性、变量归类所有，只要类被加载，这个变量就可以被使用 (类名.变量名）。所有实例化的对象共享类变量。<br>final变量：表示这个变量为常量，不能被修改。<br>2.static与final结合使用表示什么意思？<br>用来修饰成员变量与成员方法， 类似于C/C++语言中的“全局常量”。对于变量，若使用static final修饰，则表示一旦赋值，就不可修改，并且通过类名可以访问。对于方法，若使用static final修饰，则表示该方法不可覆盖，并且可以通过类名直接访问。</p>
<p>例题：下列运行结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestS &#123;</span><br><span class="line">	public static int testStatic() &#123;</span><br><span class="line">		static final int i &#x3D; 0;</span><br><span class="line">		System.out.println(i++);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		TestS t &#x3D; new TestS();</span><br><span class="line">		t.testStatic();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A.0 B.1 C.2 D.编译错误</p>
<p>答案：D。在Java语言中，不能在成员函数内部定义static变量。</p>
<h4 id="3-6-使用switch时有哪些注意事项"><a href="#3-6-使用switch时有哪些注意事项" class="headerlink" title="3.6 使用switch时有哪些注意事项"></a>3.6 使用switch时有哪些注意事项</h4><p>使用switch (expr)时，expr只能是一个枚举常量（内部 也是由整型或字符类型实现）或一个整数表达式，其中整数表达式可以是基本类型int或其对应的包装类Integer,当然也包括不同的长度整型，例如short。</p>
<p>由于byte、short和char类型的值都能够被隐式地转换为int类型，因此这些类型以及它们对应的包装类型都可以作为switch 的表达式。但是 long、 float、double、String类型不能够隐式地转换为int类型，因此它们不能被用作switch的表达式。</p>
<p>在Java7中，switch 开始支持String类型了。一般必须在case语句结尾添加break语句。</p>
<h4 id="3-7-volatile有什么作用"><a href="#3-7-volatile有什么作用" class="headerlink" title="3.7 volatile有什么作用"></a>3.7 volatile有什么作用</h4><p>volatile是一个类型修饰符(type specifier),它是被设计用来修饰被不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到它时都是直接从对应的内存当中提取，而不会利用缓存。在使用了 volatile修饰成员变量后，所有线程在任何时候所看到变量的值都是相同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread implements Readable &#123;</span><br><span class="line">	private volatile Boolean flag;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(flag) &#123;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;do</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下volatile不能代替 sychronized()此外，使用volatile会阻止编译器对代码的优化，因此会降低程序的执行效率。所以，除非迫不得已，否则，能不使用volatile就尽量不要使用volatile。</p>
<h4 id="3-8-instanceof有什么作用"><a href="#3-8-instanceof有什么作用" class="headerlink" title="3.8 instanceof有什么作用"></a>3.8 instanceof有什么作用</h4><p>instanceof是一个二元运算符，它的作用是判断一个引用类型的变量所指向的对象是否是一个类（或接口、抽象类、父类）的实例，即它左边的对象是否是它右边的类的实例该运算符返回boolean类型的数据。<br>常见的用法为：result  = object  instanceof class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestIns &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		String s &#x3D; &quot;Hello&quot;;</span><br><span class="line">		int[]a &#x3D; &#123;1,2&#125;;</span><br><span class="line">		if(s instanceof String)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">		if(s instanceof Object)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">		if(a instanceof int[])</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>true<br>true<br>true</p>
<h4 id="3-9-strictfp有什么作用"><a href="#3-9-strictfp有什么作用" class="headerlink" title="3.9 strictfp有什么作用"></a>3.9 strictfp有什么作用</h4><p>关键字strictfp是strict float point的缩写，指的是精确浮点，它用来确保浮点数运算的准确性。（依照IEEE二进制浮点数算术标准）<br>当一个类被strictfp修饰时，所有方法都会自动被strictfp修饰。因此，strictfp可以保证浮点数运算的精确性，而且在不同的硬件平台上会 有一致的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public strictfp class TestStr &#123;</span><br><span class="line">	public static void TestStr() &#123;</span><br><span class="line">		float f &#x3D; 0.12365f;</span><br><span class="line">		double d &#x3D; 0.03496421d;</span><br><span class="line">		double sum &#x3D; f+d;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		TestStr();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：0.15861420949932098</p>
<h2 id="4-基本类型与运算"><a href="#4-基本类型与运算" class="headerlink" title="4.基本类型与运算"></a>4.基本类型与运算</h2><h4 id="4-1Java提供了哪些基本数据类型"><a href="#4-1Java提供了哪些基本数据类型" class="headerlink" title="4.1Java提供了哪些基本数据类型"></a>4.1Java提供了哪些基本数据类型</h4><p>Java语言一共提供了 8种原始的数据类型<strong>（byte, short, int, long, float, double, char, boolean)</strong>,这些数据类型不是对象，而是Java语言中不同于类的特殊类型，这些基本类型的数据变量在声明之后就会立刻在<strong>栈</strong>上被分配内存空间。</p>
<p>以上这些基本类型可以分为如下4种类型： </p>
<p>1) int 长度数据类型:byte (8 bit)、short (16bit)，int (32 bit) ，long (64 bit)<br>2) float长度数据类型:单精度(32bit  float),双精度(64 bit  double)<br>3) boolean类型变量的取值：ture、false。<br>4) char 数据类 型:Unicode 字符(16 bit) </p>
<p>Java语言还提供了对这些原始数据类型的<strong>封装类（字符类型Character,布尔类型 Boolean,数值类型 Byte、Short、Integer、Long、Float、Double)</strong><br>Java语言中，默认声明的小数是double类型的，因此在对float类型的变量进行初始化时需要进行类型转换。float类型的变量有两种初始化方法： float f=l.0f或float f= (float) 1.0。</p>
<p>引申：<br>1.在Java语言中null值是什么？在内存中null是什么？<br>null不是一个合法的Object实例，所以编译器并没有为其分配内存，它仅仅用于表明该引用目前没有指向任何对象。<br>2.如何理解赋值语句String  x  = null?<br>它定义了一个变量“x”，x中存放的是String引用，此处为null。</p>
<p>例题：<br>1.下列表达式中，正确的是（      ）。<br>A. byte  b  = 128 ；  B. boolean  flag  = null；<br>C. float  f  = 0. 9239 ； D. long  a  =2147483648 L； </p>
<p>答案：D。  A中byte能表示的取值范围为[-128,127]，B中boolean 的取值只能是true或false，不能为null, C中0. 9239为double类型，需要进行数据类型转换。</p>
<p>2.String是最基本的数据类型吗？<br>答案：不是。基本数据类型包括 byte、int、char、long、float、double、  boolean 和 short。</p>
<p>3.int和Integer有什么区别？<br>答案：Java语言提供两种不同的类型，即引用类型和原始类型（或内置类型）。int是Java 语言的原始数据类型，Integer是Java语言为int提供的封装类。Java为每个原始类型提供了封装类。</p>
<p>4.赋值语句float  f  = 3. 4是否正确？<br>答案：不正确。数据3. 4默认情况下是double类型，即双精度浮点数,赋值给float类型的变量，会造成精度损失,需要进行强制类型转换，float f= (float) 3. 4或者float f = 3. 4 F写法都是可以的。</p>
<h4 id="4-2什么是不可变类"><a href="#4-2什么是不可变类" class="headerlink" title="4.2什么是不可变类"></a>4.2什么是不可变类</h4><p>指当创建了这个类的实例后，就不允许修改它的值了，一个对象一旦被创建出来，在其整个生命周期中，它的成员变量就不能被修改了。类似于常量（const)，即只允许别的程序读，不允许别的程序进行修改。</p>
<p>在Java类库中，所有基本类型的包装类都是不可变类，例如Integer、Float等。此外， String也是不可变类。</p>
<p>如何创建一个不可变类。</p>
<p>1) 类中所有成员变量被private所修饰。<br>2) 类中没有写或者修改成员变量的方法，例如set x x x ，只提供构造函数，一次生成，永不改变。<br>3) 确保类中所有方法不会被子类覆盖，可以通过把类定义为final或者把类中的方法定义为final来达到这个目的。<br>4) 如果一个类成员不是不可变量，那么在成员初始化或者使用get方法获取该成员变量时，需要通过clone方法来确保类的不可变性。<br>5) 如果有必要，可使用覆盖Object类的equals()方法和hashCode()方法。</p>
<h4 id="4-3-值传递与引用传递有哪些区别"><a href="#4-3-值传递与引用传递有哪些区别" class="headerlink" title="4.3 值传递与引用传递有哪些区别"></a>4.3 值传递与引用传递有哪些区别</h4><p>(1) 值传递<br>在方法调用中，实参会把它的值传递给形参，形参只是用实参的值初始化一个临时的存储单元，因此形参与实参虽然有着相同的值，但是却有着不同的存储单元，因此对形参的改变不会影响实参的值。<br>(2) 引用传递<br>在方法调用中，传递的是对象（也可以看作是对象的地址），这时形参与实参的对象指向同一块存储单元，因此对形参的修改就会影响实参的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	</span><br><span class="line">	public static void changeS(StringBuffer ssl,StringBuffer ssl2 ) &#123;</span><br><span class="line">		ssl.append(&quot;World&quot;);</span><br><span class="line">		ssl2&#x3D;ssl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Integer a &#x3D; 1;</span><br><span class="line">		Integer b &#x3D; a;</span><br><span class="line">		b++;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		</span><br><span class="line">		StringBuffer s1 &#x3D; new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">		StringBuffer s2 &#x3D; new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">		changeS(s1, s2);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">		System.out.println(s2);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br>1<br>2<br>HelloWorld<br>Hello</p>
<p>例题：<br>下列说法中，正确的是（        ）。<br>A. call  by  value不会改变实际参数的值<br>B. call  by  reference能改变实际参数地址<br>C. call  by  reference不能改变实际参数的地址<br>D. call  by  reference能改变实际参数的内容 </p>
<p>答案：A、C、D。</p>
<h4 id="4-4不同数据类型的转换有哪些规则"><a href="#4-4不同数据类型的转换有哪些规则" class="headerlink" title="4.4不同数据类型的转换有哪些规则"></a>4.4不同数据类型的转换有哪些规则</h4><p>当参与运算的两个变量的数据类型不同时，就需要进行隐式的数据类型转换，转换的规则为：从<strong>低精度向高精度转换</strong>，即优先级满足<br>*<em>byte  &lt; short  &lt; char  &lt; int  &lt; long  &lt; float  &lt; double *</em>,例如，不同数据类型的值在进行运算时，short类型数据能够自动转为int类型 ，int类 型数据能够自动转换为float类型等 。反之 ，则需要通过强制类型转换来实现。<br>(1)类型自动转换<br>低级数据类型可以自动转换为高级数据类型</p>
<p>1) cha类型的数据转换为高级类型（如int, long等），会转换为其对应的ASCII码。<br>2)byte, char、short 型的数据在参与运算时会自动转换为int型，但当使用“+= ”运 算时，就不会产生类型的转换。<br>3)基本数据类型与boolean类型是不能相互转换的。</p>
<p>(2)强制类型转换<br>当需要从高级数据类型转换为低级数据类型时，就需要进行强制类型转换。可能会损失精度<br>注意事项：<br>java语言在涉及byte、short和char类型的运算时，首先会把这些类型的变量值强制转换为int类型，然后对int类型的值进行计算，最后得到的值也是int 类型。<br>“+=”为Java语言规定的运算法，Java编译器会对其进行特殊处理。<br>例如：<br>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<p>例题：<br>1.下面程序的运行结果是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">		if(i)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">		else </span><br><span class="line">			System.out.println(&quot;false&quot;);</span><br></pre></td></tr></table></figure>
<p>答案：编译错误。因为if条件只接受boolean类型的值（true或false)，而i的类型为int ， int类型不能被隐式地转换为boolean类型。</p>
<p>2.对于下述代码结果强制类型转换后，变量a和b的值分别为（ );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short a &#x3D; 128 ； </span><br><span class="line">byte b &#x3D; ( byte) a</span><br></pre></td></tr></table></figure>
<p>答案： a  = 128， b  = -1。short类型变量占两个字节，a 对应的二进制为： 00000000 10000000,由于byte只占一个字节，在强制转换为byte时只截取低字节：10000000,因此b 的值为-1。</p>
<h4 id="4-5运算符优先级是什么"><a href="#4-5运算符优先级是什么" class="headerlink" title="4.5运算符优先级是什么"></a>4.5运算符优先级是什么</h4><p>单目：单目运算符+ –(负数) ++ – 等<br>乘除：算数单目运算符* / % + -<br>为：位移单目运算符&lt;&lt; &gt;&gt;<br>关系：关系单目运算符&gt; &lt; &gt;= &lt;= == !=<br>逻辑：逻辑单目运算符&amp;&amp; || &amp; | ^<br>三目：三目单目运算符A &gt; B ? X : Y<br>后：无意义，仅仅为了凑字数<br>赋值：赋值=</p>
<p>例题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte a &#x3D; 5;</span><br><span class="line">		int b &#x3D; 10;</span><br><span class="line">		int c &#x3D; a&gt;&gt;2+b&gt;&gt;2;</span><br><span class="line">		System.out.println(c);</span><br></pre></td></tr></table></figure>

<p>答案： 0。由于“+”的优先级比“》”高，因此程序中的表达式等价于a» (2+b ) »2, 相当于a»12»2,因此运行结果为0。</p>
<h4 id="4-6Math类中round、ceil和floor方法的功能各是什么"><a href="#4-6Math类中round、ceil和floor方法的功能各是什么" class="headerlink" title="4.6Math类中round、ceil和floor方法的功能各是什么"></a>4.6Math类中round、ceil和floor方法的功能各是什么</h4><p>1) round方法表示四舍五入。实现原理是在原来数字的基础上先增加0.5然后再向下取整，它的返回值类型为int型。Math. round(11.5)的结果为12，Math. round( - 11. 5)的结果为 - 11。</p>
<p>2) ceil方法的功能是向上取整。他的返回值类型是double型</p>
<p>3) floor方法的功能是向下取整。Math.floor(a),就是取小于a的最大的整数值。它的返回值类型与ceil方法一样，也是double</p>
<h4 id="4-7-如何实现无符号数的占移操作"><a href="#4-7-如何实现无符号数的占移操作" class="headerlink" title="4.7 如何实现无符号数的占移操作"></a>4.7 如何实现无符号数的占移操作</h4><p>Java提供了两种右移运算符：“&gt;&gt;”和“&gt;&gt;&gt; ”。其中，“&gt;&gt;”被称为有符号右移运算 符，“ &gt;&gt;&gt;”被称为无符号右移运算符，它们的功能是将参与运算的对象对应的二进制数右移指定的位数。二者的不同点在于“&gt;&gt;”在执行右移操作时，若参与运算的数字为正数，则在高位补0;若为负数，则在高位补1。而“ &gt;&gt;&gt;”则不同，无论参与运算的数字为正数或为负数，在执行运算时，都会在高位补0。</p>
<h4 id="4-8-char型变量中是否可以存储一个中文汉字"><a href="#4-8-char型变量中是否可以存储一个中文汉字" class="headerlink" title="4.8 char型变量中是否可以存储一个中文汉字"></a>4.8 char型变量中是否可以存储一个中文汉字</h4><p>在Java语言中，默认使用的Unicode编码方式，即每个字符占用两个字节，因此可以用来存储中文。虽然String是由char所组成的，但是它采用了一种更加灵活的方式来存储，即英文占用一个字符，中文占用两个字符。</p>
<p>例题：<br>在Java语言中，下列关于字符集编码（Character Set Encoding)和国际化（il8n)的叙述， 哪些是正确的？（     ）<br>A. 每个中文字符占用2Byte，每个英文字符占用1 Byte<br>B. 假设数据库中的字符是以GBK编码的，那么现实数据库数据的网页也必须是GBK编码的<br>C. Java的char类型，以UTF - 16 Big Endian的方式保存一个字符<br>D.实现国际化应用常用的手段是利用ResourceBundle类</p>
<p>答案：A 、D 。从上面的介绍可以得出A 是正确的，C是错误的。对于B ，数据库与Web页面可以有各自的编码，二者没有必然的关系。对于D ，ResourceBundle是一个资源处理类， 可以经常在国际化应用中使用。</p>
<h2 id="5-字符串与数组"><a href="#5-字符串与数组" class="headerlink" title="5.字符串与数组"></a>5.字符串与数组</h2><h4 id="5-1字符串创建与存储的机制是什么"><a href="#5-1字符串创建与存储的机制是什么" class="headerlink" title="5.1字符串创建与存储的机制是什么"></a>5.1字符串创建与存储的机制是什么</h4><p>1 )对于 String s1 = new String( “abc”)语句与 String s2 = new String( “abc”)语句，存在两个引用对象s 1、s 2,两个内容相同的字符串对象”a b c ”，它们在内存中的地址是不同的。只要用到new总会生成新的对象。<br>2)对于String s1 =’’abc”语句与String s2 = ’’abc”语句，在JVM中存在着一个字符串池， 其中保存着很多String对象，并且可以被共享使用，s 1 、s 2引用的是同一个常量池中的对象。</p>
<p>例题：<br>new String( “abc”）创建了几个对象？<br>答案：一个或两个。如果常量池中原来有“a b c ”，那么只创建一个对象；如果常量池中 原来没有字符串“abc”，那么就会创建两个对象。</p>
<h4 id="5-2“-’’、-equals-和-hashCode-有什么区别"><a href="#5-2“-’’、-equals-和-hashCode-有什么区别" class="headerlink" title="5.2“==’’、  equals 和 hashCode 有什么区别"></a>5.2“==’’、  equals 和 hashCode 有什么区别</h4><p>1) “ ==”运算符用来比较两个变量的值是否相等。</p>
<p>2) equals是Object类提供的方法之一。每一个Java类都继承自Object类，所以每一个对象都具有equals这个方法。Object类中定义的equals(Object)方法是直接使用“==“运算符比较的两个对象，所以在没有覆盖equals( Object)方法的情况下，equals(Object)与“==” 运算符一样，比较的是引用。</p>
<p>3) hashCode()方法是从Object类中继承过来的，它也用来鉴定两个对象是否相等。Object类中的hashCode()方法返回对象在内存中地址转换成的一个int 值，所以如果没有重写hashCode()方法，任何对象的hashCode()方法都是不相等的。<strong>在hashmap中，由于key是不可以重复的，它在判断key是否重复时就判断了hashCode()</strong></p>
<p>例题：<br>1.假设有以下代码 String s = “hello” ； String t = “hello” ； char  c  [] = {‘h’ ,‘e’ ,‘l’,‘l’,‘o’},下列选项中返回false语句的是：()<br>A. s. equals(t) B. t. equals( c) C. s == t D. t. equals( new String( “hello”））</p>
<p>答案：B。由于t 与c 分别为字符串类型和数组类型，因此返回值为 false。</p>
<p>2.下面程序的输出结果是什么？<br>String s = “abc” ；<br>String s1 = “ab” +“c”;<br>System, out. println( s == s1);</p>
<p>答案：true，“ab” + “c”在编译器就被转换为“abc”，存放在常量区，因此输出结果为true。</p>
<ol start="3">
<li>Set里的元素是不能重复的，那么用什么方法来区分是否重复呢？是用“==”还是equals()?它们有什么差别？<br>答案:用iterator()方法来区分是否重复。</li>
</ol>
<h4 id="5-3-String、StringBuffer、-StringBuilder-和-StringTokenizer-什么区別"><a href="#5-3-String、StringBuffer、-StringBuilder-和-StringTokenizer-什么区別" class="headerlink" title="5.3 String、StringBuffer、  StringBuilder 和 StringTokenizer 什么区別"></a>5.3 String、StringBuffer、  StringBuilder 和 StringTokenizer 什么区別</h4><p>Java有4个类可以对字符或字符串进行操作，Character、String、StringBuffer和StringTokenizer,其中Character用于单个字符操作，String用于字符串操作，属于不可变类，而StringBuffer也是用于字符串操作，不同之处是StringBuffer属于可变类。<br>String是不可变类，因此适合在需要被共享的场合中使用，而<strong>当一个字符串经常需要被修改时，最好使用StringBuffer来实现</strong>。String与StringBuffer的另外一个区别在于当实例化时,String可以用构造函数（new String(“”)），也可以用赋值。StringBuffer 只能使用构造函数（StringBuffer s =  new StringBuffer( “ Hello”))</p>
<p>StringBuilder也可以被修饰的字符串，它与StringBuffer类似，都是字符串缓冲区，但<strong>StringBuilder不是线程安全的</strong>，如果只是在单线程中使用字符串缓冲区，那么StringBuilder的效率会更高些。因此在<strong>只有单线程访问时可以使用StringBuilder,当有多个线程访问时，最好使用线程安全的StringBuffer</strong>。</p>
<p><strong>执行效率StringBuilder(单线程使用)&gt;StringBuffer&gt;String</strong></p>
<p>StringTokenizer是用来分割字符串的工具类。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.StringTokenizer;</span><br><span class="line">public class Testl &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		StringTokenizer st &#x3D; new StringTokenizer(&quot;Hello World!&quot;);</span><br><span class="line">		while (st.hasMoreTokens()) &#123;</span><br><span class="line">			System.out.println(st.nextToken());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>Hello<br>World!</p>
<h4 id="5-4-Java中数组是不是对象"><a href="#5-4-Java中数组是不是对象" class="headerlink" title="5.4 Java中数组是不是对象"></a>5.4 Java中数组是不是对象</h4><p>数组不仅有其自己的属性（例如length属性），也有一些方法可以被调用（例clone方法）。由于对象的特点是封装了一些数据，同时提供了 一些属性和方法，从这个角度来讲，数组是对象。每个数组类型都有其对应的类型，可以通过instanceof来判断数据的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Testl &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int []a &#x3D; &#123;1,2&#125;;</span><br><span class="line">		int [][]b &#x3D; new int[2][4];</span><br><span class="line">		String []s &#x3D; &#123;&quot;a&quot;,&quot;b&quot;&#125;;</span><br><span class="line">		</span><br><span class="line">		if(a instanceof int[]) &#123;</span><br><span class="line">			System.out.println(&quot;the type for a is int []&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">		if(b instanceof int[][]) &#123;</span><br><span class="line">			System.out.println(&quot;the type for b is int [][]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">		if(s instanceof String[]) &#123;</span><br><span class="line">			System.out.println(&quot;the type for s is String[]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>the type for a is int []<br>the type for b is int [][]<br>the type for s is String[]</p>
<h4 id="5-5-数组的初始化方式有哪几种"><a href="#5-5-数组的初始化方式有哪几种" class="headerlink" title="5.5 数组的初始化方式有哪几种"></a>5.5 数组的初始化方式有哪几种</h4><p>一维数组的声明方式为  <strong>type arrayName[ ]或 type[ ] arrayName</strong><br>Java数组在定义时，并不会给数组元素分配存储空间，因此 []中不需要指定数组的长度<br>分配方法为：<br>array Name = new type [ arraySize ] ；    // arraySize 表示数组的长度</p>
<p>完成数组的声明后，需要对其进行初始化，下面介绍两种初始化方法</p>
<p>1) int[] a= new  int[5]； //动态创建了一个包含5个整型值的数组，默认初始化为0<br>2) int[] a={1,2,3,4,5}； //声明一个数组类型变量并初始化 </p>
<p>二维数组的声明与初始化的方 式，二维数组有3种声明的方法：<br><strong>声明二维数组时，其中[]必须为空。</strong></p>
<p>1) type  array  Name  [][]；<br>2) type  [][]  arrayName；<br>3) type  []  arrayName[]；<br><img src= "/img/loading.gif" data-src="/assets/blogImg/array.png" alt="array"><br>对二维数组的访问,通过下标。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Testl &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int [][]arr &#x3D; &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;arr.length;i++) &#123;</span><br><span class="line">			for(int j &#x3D; 0;j&lt;arr[i].length;j++) &#123;</span><br><span class="line">				System.out.print(arr[i][j]+&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>1 2 3 4 5 </p>
<p>例题：<br>1.下列数组的定义中，哪3条是正确的？（  ）<br>A.public  int a  [ ]  B. static  int [ ] a C. public  [ ] int a<br>D. private  int a  [3] E. private  int [3] a  [ ] F. public  final  int [ ] a </p>
<p>答案：A、B、F。</p>
<p>2.下列数组定义及赋值中，错误的是（ ）。<br>A. int intArray[]；<br>B. intArray = new  int[3] ；intArray[ 1 ] =1; intArray[2] =2； intArray[3] =3;<br>C. int a[ ] = {1,2,3,4,5} ;<br>D. int[ ] [ ] a = new  int[2] [ ] ；a[0] = new  int[3] ；a[ 1 ] = new  int[3];</p>
<p>答案：B 。  越界</p>
<p> 3.下列说法中，错误的有（   ）。<br> A.数组是一种对象  B.数组属于一种原生类<br> C. int number[ ] = {31，23，33，43, 35，63} D.数组的大小可以任意改变 </p>
<p> 答案：B、C、D。原生类指未被实例化的类，数组一般指实例化、被分配空间的类，所以不属于原生类。</p>
<p>4.下列语句中，创建了一个数组实例的是（      ）<br>A. int[ ] a = new  int [ 15 ] ； B. float  fa = new  float  [20]；<br>C. char[ ] ca = “Some String” ； D. int a  [ ] [ ] = {4, 5 , 6} {1, 2, 3 } ； </p>
<p>答案：A</p>
<h4 id="5-6-length属性和length-方法有什么区别"><a href="#5-6-length属性和length-方法有什么区别" class="headerlink" title="5.6 length属性和length ()方法有什么区别"></a>5.6 length属性和length ()方法有什么区别</h4><p>数组提供了 length属性来获取数组的长度。<br>length()方法是针对字符串而言的，String提供了 length()方法来计算字符串的长度</p>
<p>Java中还有一个计算对象大小的方法——–size()方法， 该方法是针对泛型集合而言的，用于查看泛型中有多少个元素。</p>
<h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><h4 id="6-1finally块中的代码什么时候被执行"><a href="#6-1finally块中的代码什么时候被执行" class="headerlink" title="6.1finally块中的代码什么时候被执行"></a>6.1finally块中的代码什么时候被执行</h4><p>问题描述：try{}里有一个return语句，那么紧跟在这个try后的finally{}中的代码是否会被执行？如果会的话，什么时候被执行，在return之前还是return之后？</p>
<p>finally块里代码一定会被执行。由于程序执行return就意味着结束对当前函数的调用并跳出这个函数体，因此任何语句要执行都只能在return前执行（除非碰到exit函数），因此finally块里的代码也是在return前执行的。<br>如果try - finally或者catch - finally中都有return,那么<strong>finally块中的return语句将会覆盖别处的return语句</strong>，最终返回到调用者那里的是finally中return的值。</p>
<p>对于基本类型的数据，在finally块中改变return的值 对返回值没有任何影响，而对引用类型的数据会有影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Testl &#123;</span><br><span class="line">	public static int testFinally() &#123;</span><br><span class="line">		int result &#x3D; 1;</span><br><span class="line">		try &#123;</span><br><span class="line">			result &#x3D; 2;</span><br><span class="line">			return result;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			result &#x3D; 3;</span><br><span class="line">			System.out.println(&quot;finally!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static StringBuffer testFinally2() &#123;</span><br><span class="line">		StringBuffer s &#x3D; new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			return s;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			return null;</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			s.append(&quot;World!&quot;);</span><br><span class="line">			System.out.println(&quot;fianlly2!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		int resultVal &#x3D; testFinally();</span><br><span class="line">		System.out.println(resultVal);</span><br><span class="line">		StringBuffer resultRef &#x3D; testFinally2();</span><br><span class="line">		System.out.println(resultRef);</span><br><span class="line">	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>finally!<br>2<br>fianlly2!<br>HelloWorld!</p>
<p>问：岀现在Java程序中的finally块是不是一定会被执行？<br>答案：不一定会被执行。<br>1)当程序在进人try语句块之前就出现异常时，会直接结束，不会执行finally块中的代码<br>2)当程序在try块中强制退出时(exit(0))也不会去执行finally块中的代码</p>
<p>例题：<br>下面程序的运行结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		try &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			System.out.println(&quot;Finally&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：Finally</p>
<h4 id="6-2异常处理的原理是什么"><a href="#6-2异常处理的原理是什么" class="headerlink" title="6.2异常处理的原理是什么"></a>6.2异常处理的原理是什么</h4><p>Java语言把异常当作对象来处理，并定义了一个<strong>基类（java. lang. Throwable)作为所有异常的父类</strong>。在Java API中，已经定义了许多异常类，这些异常类分为Error (错误）和Excep­tion (异常）两大类。<br>违反语义规则包括两种情况：一种是Java类库内置的语义检查，例如当数组下标越 界时，会引发 IndexOutOfBoundsException，当访问 null 的对象时，会引发 NullPointerException；另一种情况是Java允许开发人员扩展这种语义检查，开发人员可以创建自己的异常并自由选择在何时用throw关键字拋出异常。</p>
<p>例题：<br>下列异常中，能使用throw抛出的是（       ）。<br>A.Rrror  B.Event  C. Object  D. Throwable  E. Exception   F. RuntimeException</p>
<p>答案：A、D、E、F。其中 Throwable 为异常处理的基类，Error、  Exception 和 RuntimeEx­ ception都是Throwable的子类，因此都能使用throw拋出。</p>
<h4 id="6-3运行时异常和普通异常有什么区別"><a href="#6-3运行时异常和普通异常有什么区別" class="headerlink" title="6.3运行时异常和普通异常有什么区別"></a>6.3运行时异常和普通异常有什么区別</h4><p>Error表示程序在运行期间出现了非常严重的错误，并且该错误是不可恢复的，由于这属于JVM层次的严重错误，因此这种错误是会导致程序终止执行的。<br>Exception表示可恢复的异常，是编译器可以捕捉到的。它包含两种类型：检查异常 (checked  exception)和运行时异常（ runtime  exception) </p>
<p>(1) 检查异常<br>所有继承自Exception并且不是运行时异常的异常都是检查异常，比如最常见的IO异常和SQL异常。</p>
<p>1) 异常的发生并不会导致程序出错，进行处理后可以继续执行后续的操作，例如，当连接数据库失败后，可以重新连接后进行后续操作。<br>2) 程序依赖于不可靠的外部条件，例如系统IO。</p>
<p>(2) 运行时异常<br>编译器没有强制对其进行捕获并处理。如果不对这种异常进行处理，当出现这种异常时，会由JVM来处理。最常见的运行时异常包括<strong>NullPointerException (空指针异常）、 ClassCastException (类型转换异常）ArraylndexOutOfBoundsException (数组越界异常）、ArrayStoreException (数组存储异常） 、 BufferOverflowException (缓冲区溢出异常）、ArithmeticExcep-ion (算术异常等</strong>。</p>
<p>例题：<br>1.下面程序能否编译通过？如果把ArithmeticException换成IOException呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExceptionTest &#123;</span><br><span class="line">	public void doSomething()throws ArithmeticException&#123;</span><br><span class="line">		System.out.println(&quot;test&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		ExceptionTest et &#x3D; new ExceptionTest();</span><br><span class="line">		et.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：能。ArithmeticException属于运行时异常，编译器没有强制对其进行捕获并处理，编译可以通过。IOException属于检查异常，编译器强制去捕获此类型的异常，如果不对异常进行捕获将会有编译错误。（即对et.doSomething进行try catch 包裹）</p>
<p>2.异常包含下列哪些内容？（     ）<br>A.程序中的语法错误<br>B.程序的编译错误<br>C.程序执行过程中遇到的事先没有预料到的情况<br>D.程序事先定义好的可能出现的意外情况 </p>
<p>答案：C。</p>
<p>3.下列关于异常的说法中，正确的是（ ）。<br>A. 一旦岀现异常，程序运行就终止了<br>B. 如果一个方法申明将拋出某个异常，它就必须真的拋出那个异常<br>C. 在catch子句中匹配异常是一种精确匹配<br>D. 可能拋出系统异常的方法是不需要申明异常的<br>答案：D</p>
<h2 id="7-输入输出流"><a href="#7-输入输出流" class="headerlink" title="7.输入输出流"></a>7.输入输出流</h2><h4 id="7-1Java-IO-流的实现机制是什么"><a href="#7-1Java-IO-流的实现机制是什么" class="headerlink" title="7.1Java  IO 流的实现机制是什么"></a>7.1Java  IO 流的实现机制是什么</h4><p>输人和输出都被称为抽象的流，流可以被看作一组有序的字节集合，即数据在两设备之间的传输。</p>
<p>流的本质是数据传输，根据处理数据类型的不同，流可以分为两大类：<strong>字节流和字符流。</strong><br>字节流以字节(8 bit)为单位，包含两个抽象类： InputStream (输入流）和OutputStream (输 出流）。<br>字符流以字符（16 bit)为单位，根据码表映射字符，一次可以读多个字节，它包含两个抽象类： Reader (输入流）和Writer (输出流）。</p>
<p>字节流和字符流最主要的区别为：字节流在处理输入输出时不会用到缓存，而字符流用到了缓存。</p>
<p>例题：Java中有几种类型的流？<br>答案：常见的流有两种，分别为字节流与字符流。其中，字节流继承于InputStream与 OutputStream，字符流继承于Reader与Writer。在java, io包中还有许多其他的流，流的作用主要是为了改善程序性能并且使用方便。</p>
<h4 id="7-2管理文件和目法的类是什么"><a href="#7-2管理文件和目法的类是什么" class="headerlink" title="7.2管理文件和目法的类是什么"></a>7.2管理文件和目法的类是什么</h4><p>类（File)来管理文件和文件夹，通过类不仅能够查看文件或目录的属性，而且还可以实现对 文件或目录的创建、删除与重命名等操作</p>
<p>File (Siring pathname)  根据指定的路径创建一个File对象<br>createNewFile() 若目录或文件存在，则返回false,否则创建文件或文件夹<br>delete () 删除文件或文件夹<br>isFile() 判断这个对象表示的是否是文件<br>isDirectory() 判断这个对象表示的是否是文件夹<br>listFiles() 若对象代表目录，则返回目录中所有文件的File对象<br>mkdir()  根据当前对象指定的路径创建目录<br>exists () 判断对象对应的文件是否存在 </p>
<p>例题：<br>如何列出某个目录下的所有目录和文件？<br>答案：假设目录“ C : \testDir” 下有两个文件夹（dir1和dir2) 和一个文件filel.txt，实<br>现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">public class TestFile &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		File file &#x3D; new File(&quot;C:\\testDir&quot;);</span><br><span class="line">		&#x2F;&#x2F;判断目录是否存在</span><br><span class="line">		if(!file.exists()) &#123;</span><br><span class="line">			System.out.println(&quot;directory is empty!&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		File[]fileList &#x3D; file.listFiles();</span><br><span class="line">		for(int i &#x3D; 0;i&lt;fileList.length;i++) &#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否为目录</span><br><span class="line">			if(fileList[i].isDirectory()) &#123;</span><br><span class="line">				System.out.println(&quot;directory is:&quot;+fileList[i]);</span><br><span class="line">			&#125;else if (fileList[i].isFile()) &#123;</span><br><span class="line">				System.out.println(&quot;file is :&quot;+fileList[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>directory is:C:\testDir\dir1<br>directory is:C:\testDir\dir2<br>file is :C:\testDir\file.txt</p>
<h4 id="7-3-Java-Socket-是什么"><a href="#7-3-Java-Socket-是什么" class="headerlink" title="7.3 Java  Socket 是什么"></a>7.3 Java  Socket 是什么</h4><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket也称为套接字，可以用来实现不同虚拟机或不同计算机之间的通信。</p>
<p>Java Socket可以分为两种类型：面向连接的Socket通信协议（TCP， Transmission Control Protocol,传输控制协议）和面向无连接的Socket通信协议（UDP， User Datagram Protocol，用户数据报协议）。任何一个Socket都是由IP地址和端口号唯一确定的。</p>
<p>基于TCP的通信过程如下：首先，Server  (服务器端Listen  (监听）指定的某个端口（建议使用大于1024的端口）是否有连接请求；其次Client   (客户）端向 Server端发岀Connect  (连接）请求；最后，Server端向 Client端发回Accept  (接受）消息。一个连接就建立起来了，会话随即产生。Server端和Client端都可以通过Send、 Write等方法与对方通信。</p>
<p>Socket的生命周期可以分为3个阶段：打开Socket、使用Socket收发数据和关闭Socket。</p>
<p>例题：<br>用Socket实现客户端和服务器端的通信，要求客户发送数据后能够回显相同的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		BufferedReader br &#x3D; null;</span><br><span class="line">		PrintWriter pw &#x3D; null;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			ServerSocket serverSocket &#x3D; new ServerSocket(4000);</span><br><span class="line">			Socket socket &#x3D; serverSocket.accept();</span><br><span class="line">			&#x2F;&#x2F;获取输入流</span><br><span class="line">			br &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">			&#x2F;&#x2F;获取输出流</span><br><span class="line">			pw &#x3D; new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">			</span><br><span class="line">			String s &#x3D; br.readLine();</span><br><span class="line">			pw.println(s);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				br.close();</span><br><span class="line">				pw.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		BufferedReader br &#x3D; null;</span><br><span class="line">		PrintWriter pw &#x3D; null;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			Socket socket &#x3D; new Socket(&quot;localhost&quot;, 4000);</span><br><span class="line">			&#x2F;&#x2F;获取输入流和输出流</span><br><span class="line">			br &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">			pw &#x3D; new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;向服务器发送数据</span><br><span class="line">			pw.println(&quot;客户端发来的请求Hello&quot;);</span><br><span class="line">			</span><br><span class="line">			String s &#x3D; null;</span><br><span class="line">			while(true) &#123;</span><br><span class="line">				s &#x3D;br.readLine();</span><br><span class="line">				if(s!&#x3D;null)</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				br.close();</span><br><span class="line">				pw.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动Server后运行Client,运行结果为：客户端发来的请求Hello</p>
<h4 id="7-4-什么是Java序列化"><a href="#7-4-什么是Java序列化" class="headerlink" title="7.4 什么是Java序列化"></a>7.4 什么是Java序列化</h4><p>Java提供了两种对象持久化的方式，分别为序列化和外部序列化。<br>(1 )序列化（Serialization)<br>在分布式环境下，当进行远程通信时，无论是何种类型的数据，都会以二进制序列的形式在网络上传送。序列化是一种将对象以一连串的字节描述的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、 数据库等系统里，并在需要时把该流读取出来重新构造一个相同的对象。</p>
<p>要实现序列化的类都必须实现 Serializable 接口，它里面没有包含任何方法。使用一个输出流（例如FileOntpiit- Stream)来构造一个 ObjectOutputStream (对象流）对象，紧接着，使用该对象的 writeObject (Object obj) 方法就可以将obj对象写岀（即保存其状态），要恢复时可以使用其对应的输入流。<br>序列化有以下两个特点：<br>1)如果一个类能被序列化，那么它的子类也能够被序列化。<br>2) 由于<strong>static (静态）代表类的成员</strong>， transient代表对象的临时数据，被声明为这两种类型的数据成员是不能够被序列化的。</p>
<p>(2)外部序列化<br>外部序列化与序列化主要的区别在于序列化是内置的API,只需要实现Serializable接口， 开发人员不需要编写任何代码就可以实现对象的序列化，而使用外部序列化时，Extemalizable 接口中的读写方法必须由开发人员来实现。</p>
<p>例题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line">public class TestSer implements Serializable&#123;</span><br><span class="line">	private static int i &#x3D; 0;</span><br><span class="line">	private String word &#x3D; &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">	public static void setI(int i) &#123;</span><br><span class="line">		TestSer.i &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setWord(String word) &#123;</span><br><span class="line">		this.word &#x3D; word;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一 个如下方式的 TestSer: TestSer  ts= new  TestSer( ) ； ts.setWord (“123”)；ts. setl(2)；将此对象序列化文件，并在另一个JVM中读取文件，进行反序列化，请问此时读出的DataObject对象中的word和i的值分别是</p>
<p>答案：“123”,0。Java在序列化时不会实例化static变量，因此上述代码只实例化了 word,而没有实例化i。在反序列化时只能读取到word的值，i为默认值。</p>
<h2 id="8-Java平台与内存管理"><a href="#8-Java平台与内存管理" class="headerlink" title="8.Java平台与内存管理"></a>8.Java平台与内存管理</h2><p>####8.1 为什么说Java是平台独化性语言</p>
<p>保证Java具有平台独立性的机制为“中间码”和“Java虚拟机（ Java Virtual Machine, JVM)”。<br>Java程序被编译后生成了一个“中间码”。不同的硬件平台上会安装有不同的JVM，由JVM来负责把“中间码”翻译成硬件平台能执行的代码。JVM不具有平台独立性，而是与硬件平台相关的。</p>
<p>解释执行过程分三步进行：代码的装入、代码的校验和代码的执行。装入代码的工作由 “类装载器”完成。被装入的代码由字节码校验器进行检查。</p>
<p>Java字节码的执行也分为两种方式：即时编译方式与解释执行方式，即时编译方式指的是解释器先将字节码编译成机器码，然后再执行该机器码。解释执行方式指的是解释器通过每次 解释并执行一小段代码来完成Java字节码程序的所有操作。通常采用的是解释执行方式。</p>
<p>例题：<br>1.一个Java程序运行从上到下的环境次序是（  ）。<br>A.操作系统、Java程序、JRE/JVM、硬件 B. JRE/JVM、Java程序、硬件、操作系统<br>C. Java程序、JRE/JVM、操作系统、硬件 D. Java程序、操作系统、JRE/JVM,硬件 </p>
<p>答案：C</p>
<p>2.下列说法中，正确的是（      ）。<br>A.Java程序经编译后会产生机器码   B.Java程序经编译后会产生字节码<br>C. Java程序经编译后会产生DLL  D.以上都不正确 </p>
<p>答案：B。  .java文件被javac指令编译为.class后缀的字节码文件，再由JVM执行。 </p>
<h4 id="8-2-JVM加载class文件的原理是什么"><a href="#8-2-JVM加载class文件的原理是什么" class="headerlink" title="8.2 JVM加载class文件的原理是什么"></a>8.2 JVM加载class文件的原理是什么</h4><p>Java语言是一种具有动态性的解释型语言，类(class)只有被加载到JVM中后才能运行。 这个加载过程是由类加载器来完成的，具体来说，就是由ClassLoader和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读 取到内存中。</p>
<p>类的加载方式分为隐式加载与显式加载两种。<br>隐式加载指的是程序在使用new等方式创建对象时，会隐式地调用类的加载器把对应的类加载到JVM中。<br>显式加载指的是通过直接调用class.forName()方法来把所需的类加载到JVM中。 </p>
<p>在Java语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是 保证程序运行的基础类（例如基类）完全加载到JVM中，至于其他类，则在需要时才加载。 在Java语言中，可以把类分为3类：<strong>系统类、扩展类和自定义类。</strong>对应3种类型的加载器。<br>Bootstrap Loader -负责加载系统类(jre/lib/rt. jar 的类）<br>ExtClassLoader -负责加载扩展类(jar/lib/ext/ * . jar 的类〉<br>AppClassLoader -负责加载应用类 (classpath指定的目录或jar中的类）</p>
<p>加载通过委托的方式实现的。当有类需要被加载时，类加载器会请求父类来完成这个载入工作，父类会使用其自己的搜索路径来搜索需要被载入的类，如果搜索不到，才会由子类按照其搜索路径来搜索待加载的类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestLoader &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args)throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		&#x2F;&#x2F;调用class加载器</span><br><span class="line">		ClassLoader clApp &#x3D; TestLoader.class.getClassLoader();</span><br><span class="line">		System.out.println(clApp);</span><br><span class="line">		&#x2F;&#x2F;调用上一层Class加载器 </span><br><span class="line">		ClassLoader clExt &#x3D; clApp.getParent();</span><br><span class="line">		System.out.println(clExt);</span><br><span class="line">		&#x2F;&#x2F;调用根部Class加载器 </span><br><span class="line">		ClassLoader clBoot &#x3D; clExt.getParent();</span><br><span class="line">		System.out.println(clBoot);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>sun.misc.Launcher$AppClassLoader@4e25154f<br>sun.misc.Launcher$ExtClassLoader@33909752<br>null</p>
<p>可以看出，TestLoader类是由AppClassLoader来加载的。另外，由于Bootstrap Loade是用C++语言来实现的，因此，在Java语言中是看不到它的，所以此时程序会输岀null。</p>
<p>类加载的主要步骤分为以下3步：<br>1)装载。根据查找路径找到相对应的class文件，然后导入。<br>2)链接。链接又可以分为3个小的步骤，具体如下。<br>①检查。检查待加载的class文件的正确性。<br>②准备。给类中的静态变量分配存储空间。<br>③解析。将符号引用转换成直接引用（这一步是可选的）。<br>3)初始化。对静态变量和静态代码块执行初始化工作。</p>
<h4 id="8-3什么是GC"><a href="#8-3什么是GC" class="headerlink" title="8.3什么是GC"></a>8.3什么是GC</h4><p>垃圾回收(Garbage Collection, GC)，主要作用是回收程序中不再使用的内存。<br>Java提供了 垃圾回收器来自动检测对象的作用域，可自动地把不再被使用的存储空间释放掉。具体而言， 垃圾回收器要负责完成3项任务：<strong>分配内存、确保被引用对象的内存不被错误地回收以及回收再被引用的对象的内存空间。</strong></p>
<p>垃圾回收器使用<strong>有向图来记录和管理堆内存中的所有对象**</strong>，通过这个有向图就可以识别哪些对象是“可达的”（有引用变量引用它就是“可达的”），哪些对象是“不可达的”（没有引用变量引用它就是不可达的），所有“不可达”对象都是可被垃圾回收的。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test()&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">		Integer i1 &#x3D; new Integer(1);</span><br><span class="line">		Integer i2 &#x3D; new Integer(2);</span><br><span class="line">		i2 &#x3D; i1;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行到i2=il后，内存的引用关系如图所示。<br><img src= "/img/loading.gif" data-src="/assets/blogImg/ref.png" alt="ref"><br>垃圾回收器正在进行垃圾回收操作，在遍历上述有向图时，资源2所占的内存是不可达的，垃圾回收器就会认为这块内存已经不会再被使用了，因此就会回收该块内存空间。</p>
<p>例题：<br>1.现有如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object m() &#123;</span><br><span class="line">	Object o &#x3D; new Float(3.14F);</span><br><span class="line">	Object[] oa &#x3D; new Object[1];</span><br><span class="line">	oa[0] &#x3D; o;</span><br><span class="line">	o &#x3D; null;</span><br><span class="line">	oa[0] &#x3D; null;</span><br><span class="line">	print &#39;return 0&#39; ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Float对象在第2行被创建后，什么时候能够被垃圾回收？</p>
<p>答案：当oa[0] = null;以后不再有对象引用Float对象，因此能够被垃圾回收。</p>
<p>2.下列关于垃圾回收的说法中，正确的是（  ）。<br>A. 一旦一个对象成为垃圾，就立刻被回收掉<br>B. 对象空间被回收掉之后，会执行该对象的fmalize方法<br>C. finalize方法和C++的析构函数完全是一回事情<br>D. 一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此</p>
<p>答案：D。成为垃圾的对象，只有在下次垃圾回收器运行时才会被回收，而不是马上被清 理，因此选项A错误。finalize方法是在对象空间被回收前调用的，因此选项B错误。在C+ + 语言中，调用了析构函数后，对象一定会被销毁，而Java语言调用了 fmalize方法，垃圾却不 一定会被回收，因此finalize方法与C++的析构函数是不同的，所以选项C也不正确。对于 D，当一个对象不再被引用后就成为垃圾可以被回收，但是线程就算没有被引用也可以独立运 行的，因此与对象不同。所以正确答案为D。</p>
<p>3.是否可以主动通知JVM进行垃圾回收？</p>
<p>答案：由于垃圾回收器的存在，开发人员不能实时地调用垃圾回收器对某个对象或所有对象进行垃圾回收。可以通过调用System. gc()方法来“通知”垃圾回收器运行，当然，JVM也并不会保证垃圾回收器马上就会运行。由于System. gc()方法的执行会停止所有响应（不推荐频繁使用）。</p>
<h4 id="8-4Java是否存在内存泄露问题"><a href="#8-4Java是否存在内存泄露问题" class="headerlink" title="8.4Java是否存在内存泄露问题"></a>8.4Java是否存在内存泄露问题</h4><p>内存泄露是指一个不再被程序使用的对象或变量还在内存中占有存储空间。<br>内存泄露主要有两种情况：<br>一是在堆中申请的空间没有被释放；（垃圾回收机制的引入有效地解决)<br>二是对象已不再被使用，但还仍然在内存中保留着。</p>
<p>Java语言中的内存泄露主要指的是第二种情况。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector v &#x3D; new Vector(10);</span><br><span class="line">		for(int i &#x3D; 1;i&lt;10;i++) &#123;</span><br><span class="line">			Object o &#x3D; new Object();</span><br><span class="line">			v.add(o);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>上述循环中，不断创建新的对象加到Vecto 象中，当退出循环后，o的作用域将会结束，但是由于v在使用这些对象，因此垃圾回收器无法将其回收，此时就造成了内存泄露。只有将这些对象从Vector中删除才能释放创建的这些对象。</p>
<p>在Java语言中，容易引起内存泄露的原因很多，主要有以下几个方面的内容：</p>
<p>1) 静态集合类，例如HashMap和Vector。<br>2) 各种连接，例如数据库连接、网络联接以及0连接等。<br>3) 监听器。<br>4) 变量不合理的作用域。<br>5)单例模式可能会造成内存泄露</p>
<h4 id="8-5Java中的堆和栈有什么区别"><a href="#8-5Java中的堆和栈有什么区别" class="headerlink" title="8.5Java中的堆和栈有什么区别"></a>8.5Java中的堆和栈有什么区别</h4><p>堆与栈都是内存中存放数据的地方。变量分为基本数据类型和引用类型。</p>
<p>栈：<br> 基本数据类型的变量（例如int、short、long、byte、float、double、boolean以及char等）以及对象的引用变量，其内存都分配在栈上，变量出了作用域就会自动释放。</p>
<p> 堆：引用类型的变量, 其内存分配在堆上或者常量池（例如字符串常量），需要通过new等方式进行创建。</p>
<p>从堆和栈的功能以及作用来比较，堆主要用来存放对象的，栈主要是用来执行程序的。相较于堆，栈的存取速度更快，但栈的大小和生存期必须是确定的，因此缺乏一定的灵活性。而堆却可以在运行时动态地分配内存，生存期不用提前告诉编译器，但这也导致了其存取速度的缓慢。</p>
<h2 id="9-容器"><a href="#9-容器" class="headerlink" title="9.容器"></a>9.容器</h2><h4 id="9-1Java-Collections框架是什么"><a href="#9-1Java-Collections框架是什么" class="headerlink" title="9.1Java Collections框架是什么"></a>9.1Java Collections框架是什么</h4><p>Java Collections框架中包含了大量集合接口以及这些接口的实现类和操作它们的算（例 如排序、查找、反转、替换、复制、取最小元素、取最大元素等）。<br>主要提供了 List (列表） 、 Queue (队列） 、 Set (集合） 、 Stack (栈）和Map (映射表，用于存放键值对） 等数据结构。其中，List、Queue、Set、Stack都继承Collection接口。<br>下面分别介绍Set、List和Map3个接口。</p>
<p>1) Set表示数学意义上的集合概念。其最主要的特点是集合中的<strong>元素不能重复</strong>，因此存入Set的每个元素都必须定义equals()方法来确保对象的唯一性。该接口有两个实现类：HashSet和TreeSet。其中TreeSet实现了 SortedSet接口，因此<strong>TreeSet容器中的元素是有序的。</strong></p>
<p>2) List又称为有序的Collection。它按对象进入的顺序保存对象，所以它能对列表中的每 个元素的插入和删除位置进行精确的控制。同时，它可以保存重复的对象。LinkedList、ArrayList 和 Vector都实现了List 接口。</p>
<p>3) Map提供了一个从键映射到值的数据结构。它用于保存键值对，其中值可以重复，但 键是唯一的，不能重复。Java类库中有多个实现该接口的类：HashMap、TreeMap、Linked- HashMap、WeakHashMap和IdentityHashMap。虽然它们都实现了相同的接口，但执行效率却不是完全相同的。具体而言，HashMap是基于散列表实现的，采用对象的HashCode可以进行快速查询。LinkedHashMap采用列表来维护内部的顺序。TreeMap基于红黑树的数据结构来实现的，内部元素是按需排列的。</p>
<p>例题：<br>下面哪种创建Map集合的方式是正确的？（  ）<br>A. Map  m  = new  Map()<br>B. Map  m  = new  Map( init  capacity, increment  capacity)<br>C. Map  m  = new  Map( new  Collection  ())<br>D. Map是接口，所以不能实例化</p>
<p>答案：D。由于Map是一个接口，因此不能直接实例化Map的对象，但是可以实例化实现 Map接口的类的对象，例如Map  m  = new  HashMap()。</p>
<h4 id="9-2-什么是迭代器"><a href="#9-2-什么是迭代器" class="headerlink" title="9.2 什么是迭代器"></a>9.2 什么是迭代器</h4><p>迭代器（Itemtor)是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访 问一个容器(container)对象中的各个元素，而又不必暴露该对象内部细节的方法。<br>迭代器的使用主要有以下3个方面的注意事项：<br>1 )使用容器的iterator()方法返回一个Iterator,然后通过Iterator的next()方法返回第一 个元素。<br>2) 使用Iterator的hasNext()方法判断容器中是否还有元素，如果有，可以使用next()方 法获取下一个元素。<br>3)可以通过remove()方法删除迭代器返回的元素。<br>Listlterator只存在于List中，支持在迭代期间向List中添加 或删除元素，并且可以在List中双向滚动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class IteratorTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		List&lt;String&gt; ll &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line">		ll.add(&quot;first&quot;);</span><br><span class="line">		ll.add(&quot;second&quot;);</span><br><span class="line">		ll.add(&quot;third&quot;);</span><br><span class="line">		ll.add(&quot;fourth&quot;);</span><br><span class="line">		</span><br><span class="line">		for(Iterator&lt;String&gt;iter&#x3D;ll.iterator();iter.hasNext();) &#123;</span><br><span class="line">			String str &#x3D; (String)iter.next();</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>first<br>second<br>third<br>fourth</p>
<p>Iterator与Listiterator有什么区别？<br>Iterator只能正向遍历集合，适用于获取移除元素。Listlerator继承自Iterator,专门针对 List,可以从两个方向来遍历List，同时支持元素的修改。</p>
<h4 id="9-3ArrayList，Vector和LinkedList有什么区别"><a href="#9-3ArrayList，Vector和LinkedList有什么区别" class="headerlink" title="9.3ArrayList，Vector和LinkedList有什么区别"></a>9.3ArrayList，Vector和LinkedList有什么区别</h4><p>ArrayList、Vector、LinkedList类均在java.util包中，均为可伸缩数组，即可以动态改变长度的数组。</p>
<p>ArrayList和Vector都是基于存储元素的Object[ ] array来实现的，它们会在内存中开辟一 块连续的空间来存储，由于数据存储是连续的，因此，它们支持用序号（下标）来访问元素， 同时<strong>索引数据的速度比较快</strong>。但是在插人元素时需要移动容器中的元素，所以对数据的插入操作执行得比较慢。<br>ArrayList与Vector最大的区别就是synchronization (同步）的使用，没有一个ArrayList的 方法是同步的，而Vector的绝大多数方法（例如add、insert、remove、set、equals、 hashcode 等）都是直接或者间接同步的，所以Vector是线程安全的，ArrayList不是线程安全的。<br>LinkedList是釆用双向列表来实现的，对数据的索引需要从列表头开始遍历，因此用于随 机访问则效率比较低，但是插入元素时不需要对数据进行移动，因此<strong>插人效率较高</strong>。同时， LinkedList是非线程安全的容器。</p>
<p>例题：<br>1.若线性表最常用的操作是存取第i个元素及其前趋的值，则采用（   ）存储方式节省时间。<br>A.单链表 B.双链表 C.单循环链表 D.顺序表 </p>
<p>答案：D。顺序适合在随机访问的场合使用，访问时间复杂度为0(1),而列表的随机访问操作的时间复杂度为0( n)。</p>
<p>2.对于import  java, util包，下列说法中，错误的是（  ）。<br>A. Vector 类属于 java* util 包      B. Vector 类放在  ./java/util/目录下<br>C. Vector类放在java, util文件中      D. Vector类是Sun公司的产品</p>
<p>答案：C。</p>
<h4 id="9-4HashMap、HashTable、-TreeMap和WeakHashMap哪些区別"><a href="#9-4HashMap、HashTable、-TreeMap和WeakHashMap哪些区別" class="headerlink" title="9.4HashMap、HashTable、  TreeMap和WeakHashMap哪些区別"></a>9.4HashMap、HashTable、  TreeMap和WeakHashMap哪些区別</h4><p>Java为数据结构中的映射定义了一个接口 java<em>util.Map,它包括3个实现类：*</em>HashMap、 HashTable和TreeMap。 **<br>Map是用来存储键值对的数据结构，在数组中通过数组下标来对其内 容索引的，而在Map中，则是通过对象来进行索引，用来索引的对象叫做key，其对应的对象 叫做value。</p>
<p>HashMap是一个最常用的Map,它根据键的HashCode值存储数据，根据键可以直接获取 它的值，具有很快的访问速度。<br>HashMap与HashTable都采用了hash法进行索引,他们区别如下：</p>
<p>1)HashMap是HashTable的轻量级实现（非线程安全的实现），它们都完成了 Map接口， 主要区别在于<strong>HashMap允许空（null)键值(key)</strong>(但需要注意，最多只允许一条记录的键 为null,不允许多条记录的值为null)，而HashTable不允许。</p>
<p>2)HashMap把HashTable的contains方法去掉了，改成 containsvalue,containsKey，因为contains方法容易让人引起误解。HashTable继承自Dictionary类，而HashMap是Java    1. 2引入的Map  interface的一个实现。</p>
<p>3)<strong>HashTable的方法是线程安全的</strong>，而HashMap不支持线程的同步，所以它不是线程安全的。在多个线程访问HashTable时，不需要开发人员对它进行同步，HashMap开发人员必须提供额外的同步机制。</p>
<p>4)HashTable使用Enumeration, HashMap使用Iterator。</p>
<p>5) HashTable和HashMap采用的hash/rehash算法都几乎一样，所以性能不会有很大的<br>差异。</p>
<p>6) 在HashTable中，hash数组默认大小是11，增加的方式是old x2 + 1。在HashMap中， hash数组的默认大小是16,而且一定是2的指数。</p>
<p>7) hash值的使用不同，HashTable直接使用对象的hashCode。</p>
<p>HashMap里面存入的键值对在取岀时没有固定的顺序，是随机的。<br>TreeMap实现了SortMap接口，能够把它保存的记录根据键排序，因此，取出来的是排序后的键值对，如果需要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</p>
<p>Weak Hash Map与HashMap类似，二者的不同之处在于WeakHashMap中key采用的是“弱引用”的方式，只要WeakHashMap中的key不再被外部引用，它就可以被垃圾回收器回收。 而HashMap中key采用的是“强引用的方式”，当HashMap中的key没有被外部引用时，只有在这个key从HashMap中删除后，才可以被垃圾回收器回收。</p>
<p>例题：<br>1.在HashTable上下文中，同步指的是什么？</p>
<p>答案：同步意味着在一个时间点只能有一个线程可以修改hash表，任何线程在执行HashTable的更新操作前都需要获取对象锁，其他线程则等待锁的释放。</p>
<p>2.如何实现HashMap的同步？<br>答案：HashMap可以通过<strong>Map m = Collections. synchronizedMap( new HashMap())</strong>来达到同步的效果。具体而言，该方法返回一个同步的Map，该Map封装了底层的HashMap的所有方法，使得底层的HashMap即使是在多线程的环境中也是安全的。</p>
<h4 id="9-5用自定义类作为HashMap或HashTable的key需要注意哪些问题"><a href="#9-5用自定义类作为HashMap或HashTable的key需要注意哪些问题" class="headerlink" title="9.5用自定义类作为HashMap或HashTable的key需要注意哪些问题"></a>9.5用自定义类作为HashMap或HashTable的key需要注意哪些问题</h4><p>开发者在使用自定义类作为HashMap的key时，需要注意以下几个问题： </p>
<p>1)如果想根据对象的相关属性来自定义对象是否相等的逻辑，此时就需要重写equals()<br>方法，一旦重写了equals()方法，那么就必须重写hashCode()方法。<br>2)当自定义类的多项作为HaShMap(HaShTable)的key时，最好把这个类设计为不可<br>变类。<br>3)从HashMap的工作原理可以看出，如果两个对象相等，那么这两个对象有着相同的 hashCode,反之则不成立。</p>
<h4 id="9-6-Collection和-Collections有什么区别"><a href="#9-6-Collection和-Collections有什么区别" class="headerlink" title="9.6 Collection和 Collections有什么区别"></a>9.6 Collection和 Collections有什么区别</h4><p>Collection是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。实现该 接口的类主要有List和Set,该接口的设计目标是为各种具体的集合提供最大化的统一的操作方式。<br>Collections是<strong>针对集合类的一个包装类</strong>，它提供一系列静态方法以实现对各种集合的搜索、排序、线程安全化等操作，其中大多数方法都是用来处理线性表。Collections类不能实例化，如同一个工具类，服务于Collection框架。若在使用Collections类的方法时，对应的collec­tion的对象为null, 则这些方法都会抛出NullPointerException。<br>使用Collections的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		List&lt;Integer&gt;list &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">		int array[] &#x3D; &#123;1,7,3,2&#125;;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;array.length;i++) &#123;</span><br><span class="line">			list.add(new Integer(array[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.sort(list);</span><br><span class="line">		for(int i &#x3D; 0;i&lt;array.length;i++) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>1<br>2<br>3<br>7</p>
<h2 id="10-多线程"><a href="#10-多线程" class="headerlink" title="10.多线程"></a>10.多线程</h2><h4 id="10-1-什么是线程？它与进程有什么区别？为什么要使用多线程"><a href="#10-1-什么是线程？它与进程有什么区别？为什么要使用多线程" class="headerlink" title="10.1 什么是线程？它与进程有什么区别？为什么要使用多线程"></a>10.1 什么是线程？它与进程有什么区别？为什么要使用多线程</h4><p>线程是指程序在执行过程中，能够执行程序代码的一个执行单元。java中线程有4种状态：运行、就绪、挂起和结束。<br>进程是指一段正在执行的程序。</p>
<p>好处：</p>
<p>1) 使用多线程可以减少程序的响应时间。<br>2) 与进程相比，线程的创建和切换开销更小。<br>3) 多CPU或多核计算机本身就具有执行多线程的能力，如果使用单个线程，将无法重复 利用计算机资源，造成资源的巨大浪费。<br>4) 使用多线程能简化程序的结构，使程序便于理解和维护。一个非常复杂的进程可以分 成多个线程来执行。</p>
<h4 id="10-2-同步和异步有什么区别"><a href="#10-2-同步和异步有什么区别" class="headerlink" title="10.2 同步和异步有什么区别"></a>10.2 同步和异步有什么区别</h4><p>当多个线程需要访问同一个资源时，需要以某种顺序来确保该资源在某一时刻只能被一个线程使用，否则，程序的运行结果将会是不可预料的，在这种情况下就必须对数据进行同步，例如多个线程同时对同一数据进行写操作，即当线程A需要使用某个资源时，如果这个资源正在被线程B使用，同步机制就会让线程A—直等待下去，直到线程B结束对该资源的使用后，线程A才能使用这个资源。<br>要想实现同步操作，必须要获得每一个线程对象的锁。获得它可以保证在同一时刻只有一个线程能够进入临界区（访问互斥资源的代码块），并且在这个锁被释放之前，其他线程就不能再进入这个临界区。如果还有其他线程想要获得该对象的锁，只能进入等待队列等待。只有当拥有该对象锁的线程退出临界区时，锁才会被释放，等待队列中优先级最高的线程才能获得该锁，从而进入共享代码区。<br>实现同步的方式有两种：一 种是利用同步代码块来实现同步；另一种是利用同步方法来实现同步。</p>
<p>异步与非阻塞类似，由于每个线程都包含了运行时自身所需要的数据或方法，因此，在进行输入输出处理时，不必关心其他线程的状态或行为，也不必等到输人输岀处理完毕才返回。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，异步能够提高程序的效率。</p>
<h4 id="10-3-如何实现Java多线程"><a href="#10-3-如何实现Java多线程" class="headerlink" title="10.3 如何实现Java多线程"></a>10.3 如何实现Java多线程</h4><p>(1)继承Thread类，重写run()方法<br>Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()方法。调用start()方法后并不是立即执行多线程代码，而是使得该线程变为可运行态（Riirmable)，什么时候运行多线程代码是由操作系统决定的。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mythread extends Thread &#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread()+&quot;--&gt;&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestThread&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Mythread thread &#x3D; new Mythread();</span><br><span class="line">		&#x2F;&#x2F;启动线程</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br>Thread[Thread-0,5,main]–&gt;0<br>Thread[Thread-0,5,main]–&gt;1<br>Thread[Thread-0,5,main]–&gt;2<br>Thread[Thread-0,5,main]–&gt;3<br>Thread[Thread-0,5,main]–&gt;4<br>Thread[Thread-0,5,main]–&gt;5<br>Thread[Thread-0,5,main]–&gt;6<br>Thread[Thread-0,5,main]–&gt;7<br>Thread[Thread-0,5,main]–&gt;8<br>Thread[Thread-0,5,main]–&gt;9</p>
<p>(2)实现Runnable接口，并实现该接口的run()方法 </p>
<p>1) 自定义类并实现Runnable接口，实现run()方法。<br>2) 创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。<br>3) 调用 Thread 的 start()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Task implements Runnable &#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread()+&quot;--&gt;&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestThread&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Thread thread &#x3D; new Thread(new Task());</span><br><span class="line">		&#x2F;&#x2F;启动线程</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>Thread[Thread-0,5,main]–&gt;0<br>Thread[Thread-0,5,main]–&gt;1<br>Thread[Thread-0,5,main]–&gt;2<br>Thread[Thread-0,5,main]–&gt;3<br>Thread[Thread-0,5,main]–&gt;4<br>Thread[Thread-0,5,main]–&gt;5<br>Thread[Thread-0,5,main]–&gt;6<br>Thread[Thread-0,5,main]–&gt;7<br>Thread[Thread-0,5,main]–&gt;8<br>Thread[Thread-0,5,main]–&gt;9</p>
<p>(3)实现Callable接口，重写call()方法<br>Callable接口实际是属于Executor框架中的功能类，Callable接口与Runnable接口的功能 类似，但提供了比Runnable更强大的功能，主要表现为以下3点： </p>
<p>1) Callable可以在任务结束后提供一个返回值，Rurmable无法提供这个功能。<br>2) Callable中的call()方法可以抛岀异常，而Rumiable的run()方法不能抛出异常。<br>3) 运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。</p>
<p>引申：一个类是否可以同时继承Thread与实现Runnable接口？<br>答案：可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestThread extends Thread implements Runnable&#123;</span><br><span class="line">	</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;Run!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Thread thread &#x3D; new Thread(new TestThread());</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：Run!</p>
<h4 id="10-4-run-方法与start-方法有什么区別"><a href="#10-4-run-方法与start-方法有什么区別" class="headerlink" title="10.4 run()方法与start()方法有什么区別"></a>10.4 run()方法与start()方法有什么区別</h4><p>系统通过调用线程类的Start()方法来启动一个线程，此时该线程处于就绪状态, 而非运行状态，也就意味着这个线程可以被JVM来调度执行。在调度过程中，JVM通过调用线程类的run()方法来完成实际的操作，当run()方法结束后，此线程就会终止。</p>
<p>如果直接调用线程类的run()方法，这会被当作一个普通的函数调用，程序中仍然只有主线程这一个线程，也就是说，start方法（）能够异步地调用run()方法，但是直接调用run()方法却是同步的，因此也就无法达到多线程的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ThreadDemo extends Thread&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;Demo:begin&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;Demo:end&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestThread&#123;</span><br><span class="line">	public static void test1() &#123;</span><br><span class="line">		System.out.println(&quot;Test1:begin&quot;);</span><br><span class="line">		Thread t1 &#x3D; new ThreadDemo();</span><br><span class="line">		t1.start();</span><br><span class="line">		System.out.println(&quot;Test1:end&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void test2() &#123;</span><br><span class="line">		System.out.println(&quot;Test2:begin&quot;);</span><br><span class="line">		Thread t2 &#x3D; new ThreadDemo();</span><br><span class="line">		t2.start();</span><br><span class="line">		System.out.println(&quot;Test2:end&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		test1();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(5000);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		test2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>Test1:begin<br>Test1:end<br>Demo:begin<br>Demo:end</p>
<p>Test2:begin<br>Demo:begin<br>Demo:end<br>Test2:end</p>
<p>从test1的运行结果可以看出线程t1是在test1方法结束后才执行的System.out.println(“Test1:end”);语句不需要等待t1.start()运行结果就可以执行，因此，在test1中调用start()方法是异步的，main线程与tl线程是异步执行的。</p>
<p>从test2的运行结果可以看岀，调用t2.run()是同步的调用方法，因为System.out.println(“Test2:end”);只有等t2. run()调用结束后才能执行。</p>
<h4 id="10-5多线程同步的实现方法有哪些"><a href="#10-5多线程同步的实现方法有哪些" class="headerlink" title="10.5多线程同步的实现方法有哪些"></a>10.5多线程同步的实现方法有哪些</h4><p>Java主要提供了3种实现同步机制的方法：<br>(1) synchronized关键字<br>每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许一个线程所拥有，当一个线程调用对象的一段synchronized代码时，需要先获取这个锁，然后去执行相应的代码，执行结束后，释放锁。</p>
<p>1) synchronized方法。在方法的声明前加人synchronized关键字，示例如下：<br>public synchronized void mutiThreadAccess ()；<br>只要把多个线程对类需要被同步的资源的操作放到mutiThreadAccess()方法中，就能保证这个方法在同一时刻只能被一个线程访问，从而保证了多线程访问的安全性。<br>2) synchronized块。synchronized块既可以把任意的代码段声明为synchronized,也可以指定上锁的对象，有非常高的灵活性。其用法如下：<br>synchronized (syncObject){<br>//访问syncObject的代码<br>}</p>
<p>( 2 ) wait()方法与notify()方法<br>当使用synchronized来修饰某个共享资源时，如果线程A1在执行synchronized代码，另外 一个线程A2也要同时执行同一对象的同一synchronized代码时，线程A2将要等到线程A1执行完成后，才能继续执行。在这种情况下可以使用wait()方法和notify()方法。<br>在synchronized代码被执行期间，线程可以调用对象的wait()方法，释放对象锁，进人等 待状态，并且可以调用notify()方法或notifyAll()方法通知正在等待的其他线程。notify()方法仅唤醒一个线程（等待队列中的第一个线程）并允许它去获得锁，notifyAlI()方法唤醒所有等 待这个对象的线程并允许它们去获得锁（并不是让所有唤醒线程都获取到锁，而是让它们去竞争）。</p>
<p>(3) Lock</p>
<p>1) lock()以阻塞的方式获取锁，也就是说，如果获取到了锁，立即返回；如果别的线<br>程持有锁，当前线程等待，直到获取锁后返回。<br>2) tryLock()以非阻塞的方式获取锁。只是尝试性地去获取一下锁，如果获取到锁，立<br>即返回true，否则，立即返回false。<br>3) tryLock( long  timeout, TimeUnit  unit)。如果获取了锁，立即返回true，否则会等待参数给定的时间单元，在等待的过程中，如果获取了锁，就返回true,如果等待超时，返回false。<br>4) lockInterruptibly()。如果获取了锁，立即返回；如果没有获取锁，当前线程处于休眠 状态，直到获得锁，或者当前线程被别的线程中断（会收到IntermptedException异常）。</p>
<h4 id="10-6sleep-方法与wait-方法有什么区別"><a href="#10-6sleep-方法与wait-方法有什么区別" class="headerlink" title="10.6sleep()方法与wait()方法有什么区別"></a>10.6sleep()方法与wait()方法有什么区別</h4><p>sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法，例 如，当线程交互时，如果线程对一个同步对象x发出一个wait()调用请求，那么该线程会暂停执行，被调对象进人等待状态，直到被唤醒或等待时间超时。<br>区别如下：<br>1)原理不同。<br>sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使 此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动 “苏醒”。<br>而wait ()方法是Object类的方法，用于线程间的通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程调用notify()方法（或notifyAll()方法）时才“醒”来，</p>
<p>2) 对锁的处理机制不同。由于sleepO方法的主要作用是让线程暂停执行一段时间，时间 一到则自动恢复，不涉及线程间的通信，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他 synchronized数据可被别的线程使用。</p>
<p>3) 使用区域不同。由于wait()方法的特殊意义，因此它必须放在同步控制方法或者同步 语句块中使用，而sleep()方法则可以放在任何地方使用。<br>sleep()方法必须捕获异常，而wait( )、  notify  ()以及notifyall()不需要捕获异常。</p>
<p>例题：<br>1.利用Thread. wait()同步线程，可以设置超时时间吗？</p>
<p>答案：可以设置超时，函数原型为wait  (long  timeout)和 wait  (long  timeout, int  nanos) timeout代表最长的等待时间，单位为ms; nanos代表额外的等待时间，单位为ns。</p>
<p>2.在一个线程中sleep()方法，将使该线程在多长时间后获得对CPU的控制（假设睡<br>眠过程中不会有其他事件唤醒该线程）？<br>A.正好1000 ms  B.少于1000 ms  C.大于等于1000 ms  D.不一定</p>
<p>答案：C。Sleep()方法指定的时间为线程不会运行的最短时间。当睡眠时间结束后，线程会返回到可运行状态，不是运行状态，还需要等待CPU调度执行。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。</p>
<h4 id="10-7终止线程的方法有哪些"><a href="#10-7终止线程的方法有哪些" class="headerlink" title="10.7终止线程的方法有哪些"></a>10.7终止线程的方法有哪些</h4><p>可以使用stop()方法与suspend()方法来终止线程的执行。<br>当用 Thread. stop()来终止线程时，它会释放已经锁定的所有监视资源。<br>调用suspend()方法不会释放锁，容易发生死锁（死锁指的是两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，如果无外力作用，它们都将无法推进）。</p>
<p>建议采用的方法是让线程自行结束进人Dead状态。一个线程进入Dead状态，即执行完run()方法，如果想要停止一个线程的执行，就要提供某种方式让线程能够自动结束run()方法的执行。在实现时，可以通过设置一个flag标记来控制循环是否执行，通过这种方法来让线程离开run()方法从而终止线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread </span><br><span class="line">&#123; </span><br><span class="line">    public volatile boolean exit &#x3D; false; </span><br><span class="line"> </span><br><span class="line">    public void run() </span><br><span class="line">    &#123; </span><br><span class="line">        while (!exit) &#123;</span><br><span class="line">        	System.out.println(&quot;Do something!&quot;);</span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">    public static void main(String[] args) throws Exception </span><br><span class="line">    &#123; </span><br><span class="line">        MyThread thread &#x3D; new MyThread(); </span><br><span class="line">        thread.start(); </span><br><span class="line">        sleep(1000); &#x2F;&#x2F; 主线程延迟1秒 </span><br><span class="line">        thread.exit &#x3D; true;  &#x2F;&#x2F; 终止线程thread </span><br><span class="line">        thread.join(); </span><br><span class="line">        System.out.println(&quot;线程退出!&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程处于非运行状态时（当slee()方法被调用或当wait()方法被调用或当被I/O阻塞时），上面介绍的方法就不可用了。此时可以使用intemipt()方法来打破阻塞的情况，当interrupt()方法被调用时，会抛出IntemiptedException异常，可以通过在run()方法中捕获这个异常来让线程安全退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread </span><br><span class="line">&#123; </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;   </span><br><span class="line">    	Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">			</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					System.out.println(&quot;thread go to sleep&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;用休眠来模拟线程被阻塞</span><br><span class="line">						Thread.sleep(5000);</span><br><span class="line">						System.out.println(&quot;thread finish&quot;);</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(&quot;thread is interupted!&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">    	thread.start();</span><br><span class="line">    	thread.interrupt();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：<br>thread go to sleep<br>thread is interupted!</p>
<h4 id="10-8synchronized-与Lock-有什么区别"><a href="#10-8synchronized-与Lock-有什么区别" class="headerlink" title="10.8synchronized 与Lock 有什么区别"></a>10.8synchronized 与Lock 有什么区别</h4><p>Java语言提供了两种锁机制来实现对某个共享资源的同步：<br>synchronized使用Object对象本身的notify、wait、notityAll调度机制，而 Lock可以使用 Condi­tion进行线程之间的调度，完成synchronized实现的所有功能。<br>(省略一下，待补充）</p>
<h4 id="10-9什么是守护线程"><a href="#10-9什么是守护线程" class="headerlink" title="10.9什么是守护线程"></a>10.9什么是守护线程</h4><p>Java提供了两种线程：守护线程与用户线程。守护线程又被称为“服务进程” “精灵线 程”或“后台线程”，是指在程序运行时在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。<br>任何一个守护线程都是整个JVM中所有非守护线程的 “保姆”。<br>如果用户线程已经全部退出运行, 只剩下守护线程存在了，JVM也就退出了。因为当所有非守护线程结束时，没有了被守护者， 守护线程也就没有工作可做了，也就没有继续运行程序的必要了，程序也就终止了，同时会 “杀死”所有守护线程。</p>
<p>将一个用户线程设置为守护线程的方法就是在调用start()方法启动线程之前调用对象的setDaemon()方法，若将以上参数设置为false，则表示的是用户进程模式。需要注意的是，当在一个守护线程中产生了其他线程，那么这些新产生的线程默认还是守护线程，用户线程也是如此。</p>
<p>例题：<br>1.Java的Daemon线程，setDaemon 设置必须要（）<br>A.在调用start()方法之前 B.在调用start()方法之后 C.在调用start()方法前后均可</p>
<p>答案：A</p>
<p>2.关于守护线程的说法，正确的是（ ）。<br>A.所有非守护线程终止，即使存在守护线程，进程运行终止<br>B.所有守护线程终止，即使存在非守护线程，进程运行终止<br>C.只要有守护线程或者非守护进程其中之一存在，进程就不会终止<br>D.只要所有守护线程和非守护线程终止运行之后，进程才会终止</p>
<p>答案：A</p>
<h4 id="10-10join-方法的作用是什么"><a href="#10-10join-方法的作用是什么" class="headerlink" title="10.10join()方法的作用是什么"></a>10.10join()方法的作用是什么</h4><p>join()方法的作用是让调用该方法的线程在执行完run()方法后，再执行join方法后面的代码。简单点说，就是将两个线程合并，用于实现同步功能。<br>t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyThreads implements Runnable&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(&quot;begin:mythread!&quot;);</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">			System.out.println(&quot;end:mythread!&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public class JoinTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO 自动生成的方法存根</span><br><span class="line">		Thread thread &#x3D; new Thread(new MyThreads());</span><br><span class="line">		thread.start();</span><br><span class="line">		try &#123;</span><br><span class="line">			thread.join(1000);&#x2F;&#x2F;主线程等待thread结束1秒</span><br><span class="line">			if(thread.isAlive())&#x2F;&#x2F;thread已经结束</span><br><span class="line">				System.out.println(&quot;thread has not finished!&quot;);</span><br><span class="line">			else</span><br><span class="line">				System.out.println(&quot;thread has finished!&quot;);</span><br><span class="line">			System.out.println(&quot;jion Finish!&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>begin:mythread!<br>thread has not finished!<br>jion Finish!<br>end:mythread!</p>
<h2 id="11-Java数据库操作"><a href="#11-Java数据库操作" class="headerlink" title="11. Java数据库操作"></a>11. Java数据库操作</h2><h4 id="11-1如何通过JDBC连接数据庫"><a href="#11-1如何通过JDBC连接数据庫" class="headerlink" title="11.1如何通过JDBC连接数据庫"></a>11.1如何通过JDBC连接数据庫</h4><p>1)加载JDBC驱动器。将数据库的JDBC驱动加载到classpath中，在基于JavaEE的Web 应用开发过程中，通常要把目标数据库产品的JDBC驱动复制到WEB  -INF/lib下。<br>2)加载JDBC驱动，并将其注册到DriverManager中。一般使用反射Class. forName    ( String driveName  ) 0<br>3)建立数据库连接，取得 Connection 对象。一般通过 DriverManager.getConnection ( url，username, passwd)方法实现，其中，url表示连接数据库的字符串，username表示连接数据库的用户名，passwd表示连接数据库的密码。<br>4)建立 Statement 对象或是 PreparedStatement 对象。<br>5)执行SQL语句。<br>6)访问结果集ResultSet对象。<br>7)依次将 ResultSet、Statement、PreparedStatement、 Connection 对象关闭，释放掉所占用 资源，例如rs.close(),con.close()等。</p>
<p>1.JDBC的主要功能有（     ）。<br>A.创建与数据库的连接 B.发送SQL语句到数据库中<br>C.处理数据并查询结果  D.以上都是</p>
<p>答案：D </p>
<p>2.提供Java存取数据库能力的包是？<br>答案：Java.sql</p>
<h4 id="11-2JDBC处理事务采取什么方法"><a href="#11-2JDBC处理事务采取什么方法" class="headerlink" title="11.2JDBC处理事务采取什么方法"></a>11.2JDBC处理事务采取什么方法</h4><p>一个事务是由一条或多条对数据库操作的SQL语句所组成的一个不可分割的工作单元， 只有当事务中的所有操作都正常执行完了，整个事务才会被提交给数据库。在JDBC中，一般是通过commit()方法或rollback()方法来结束事务的操作。其中commit()方法表示完成对事务 的提交， rollback )方法表示完成事务回滚，多用于在处理事务的过程中出现了异常的情况， 这两种方法都位于java.ql.Connection类中。一般而言，事务默认操作是自动提交，即操作成功后，系统将自动调用commit()方法，否则将调用rollback()方法。</p>
<h4 id="11-3Class-forName的作用是什么"><a href="#11-3Class-forName的作用是什么" class="headerlink" title="11.3Class.forName的作用是什么"></a>11.3Class.forName的作用是什么</h4><p>任何类只有被装载到JVM上才能运行。Class.forName()方法的作用就是把类加载到JVM中，它会返回一个与带有给定字符串名的类或接口相关联的Class对象，并且JVM会加载这个类，同时JVM会执行该类的静态代码段。</p>
<p>JDBC规范中要求Driver类在使用前必须向DriverManager注册自己，所以，当执行<br>Class.forName(“com.mysql.jdbc.Driver”）时，JVM会加载名为’com.mysql.jdbc.Driver”对应的Driver类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Driver extends NonRegisteringDriver implements Java. sql.Driver &#123; </span><br><span class="line">  static &#123;</span><br><span class="line">    try &#123;  </span><br><span class="line">      java.sql.DriverManager.registerDriver( new Driver())； </span><br><span class="line">    &#125; catch (SQLException E) &#123; </span><br><span class="line">      throw new RuntimeException( &quot; Can&#39;t register driver!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在调用Class. forName()方法时，这个Driver类被加载了，由于静态部分被执行，因此 Driver 也被注册到了 DriverManager 中。</p>
<h4 id="11-4Statement-PreparedStatement和CallableStatement有什么区别"><a href="#11-4Statement-PreparedStatement和CallableStatement有什么区别" class="headerlink" title="11.4Statement,PreparedStatement和CallableStatement有什么区别"></a>11.4Statement,PreparedStatement和CallableStatement有什么区别</h4><p>Statement<strong>用于执行不带参数的简单SQL语句</strong>，并返回它所生成结果的对象，每次执行SQL语句时，数据库都要编译该SQL语句。</p>
<p>PreparedStatement表示预编译的SQL语句的对象，<strong>用于执行带参数的预编译SQL语句。</strong>(执行插入、更新、删除等操作，最好使用PreparedStatement</p>
<p>CallableStatement则提供了用来调用数据库中存储过程的接口，如果有输出参数要注册，说明是输出参数。<br>CallableStatement由prepareCall()方法所创建，它为所有 DBMS ( Database Management Sys­ tem, 数据库管理系统）提供了一种以标准形式调用已储存过程的方法。</p>
<p>例题：<br>1.用于调用存储过程的对象是()。<br>A. ResultSet  B. DriverManager  C. CallableStatemet  D. PreparedStatement </p>
<p>答案：C</p>
<h4 id="11-5getString-方法和getObject-方法有什么区别"><a href="#11-5getString-方法和getObject-方法有什么区别" class="headerlink" title="11.5getString()方法和getObject()方法有什么区别"></a>11.5getString()方法和getObject()方法有什么区别</h4><p>getStrin()或getlnt()等方法在被调用时，程序会一次性地把数据都放到内存中，然后通过调用ResultSet的next()和getString()等方法来获取数据。当数据量大到内存中放不下时就 会拋出异常，而使用getObject()方法就不会这种问题，因为数据不会一次性被读到内存中， 每次调用时会直接从数据库中去获取数据，因此使用这种方法不会因为数据量过大而出错。</p>
<h4 id="11-6什么是JDO"><a href="#11-6什么是JDO" class="headerlink" title="11.6什么是JDO"></a>11.6什么是JDO</h4><p>Java数据对象(Java  Data  Object，JDO)是一个用于存取某种数据仓库中的对象的标准化 API,它使开发人员能够间接地访问数据库。<br>JDO是JDBC的一个补充，它提供了透明的对象存储，因此对开发人员来说，存储数据对 象完全不需要额外的代码(例如JDBC API的使用)。相较于JDBC， JDO更灵活、更通用，它提供了到任何数据底层的存储功能，例如关系数据库、文件、 XML 以及对象数据库管理系统（ Object Database Management System，ODBMS)等，使得应用可移植性更强。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ayu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://x2yu.com/2019/03/23/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/">http://x2yu.com/2019/03/23/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://x2yu.com" target="_blank">阿鱼的碎碎念</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="/assets/cover/mysql_random.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/03/31/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95-Java-Web%E7%AF%87/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java程序员--Java Web篇</div></div></a></div><div class="next-post pull-right"><a href="/2019/03/21/%E7%99%BD%E8%9B%87-%E7%BC%98%E8%B5%B7/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">白蛇 缘起</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/04/21/Java程序员-数据结构与算法续篇/" title="Java程序员-数据结构与算法续篇"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-21</div><div class="relatedPosts_title">Java程序员-数据结构与算法续篇</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/15/JVM问题总结/" title="JAVA JVM基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-15</div><div class="relatedPosts_title">JAVA JVM基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/13/JUC问题总结/" title="JAVA JUC基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-13</div><div class="relatedPosts_title">JAVA JUC基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/10/29/正则表达式/" title="正则表达式"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-29</div><div class="relatedPosts_title">正则表达式</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/08/排序算法小结/" title="经典排序算法"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-08</div><div class="relatedPosts_title">经典排序算法</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/10/数据库练习题/" title="数据库练习题"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-10</div><div class="relatedPosts_title">数据库练习题</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Ayu</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>