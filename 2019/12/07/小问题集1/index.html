<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>小问题集1 | 阿鱼的碎碎念</title><meta name="description" content="胡乱整理的问题集到处都是问题，查漏补缺 1.String的APiString类属于引用数据类型,且不能被继承。 String s &#x3D; new String(&quot;TEST&quot;);   获取类的方法  length()获取类的长度 int i &#x3D; s.length() 获取指定位置的字符 char ch &#x3D; s.charAt(0) 返回”ch”在字符串中第一次出现的的位置。四种重载 int j &#x3D; s.i"><meta name="keywords" content="面试,问题集"><meta name="author" content="鱼歌唱晚"><meta name="copyright" content="鱼歌唱晚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="canonical" href="http://x2yu.com/2019/12/07/%E5%B0%8F%E9%97%AE%E9%A2%98%E9%9B%861/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="小问题集1"><meta property="og:url" content="http://x2yu.com/2019/12/07/%E5%B0%8F%E9%97%AE%E9%A2%98%E9%9B%861/"><meta property="og:site_name" content="阿鱼的碎碎念"><meta property="og:description" content="胡乱整理的问题集到处都是问题，查漏补缺 1.String的APiString类属于引用数据类型,且不能被继承。 String s &#x3D; new String(&quot;TEST&quot;);   获取类的方法  length()获取类的长度 int i &#x3D; s.length() 获取指定位置的字符 char ch &#x3D; s.charAt(0) 返回”ch”在字符串中第一次出现的的位置。四种重载 int j &#x3D; s.i"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-12-07T12:37:03.000Z"><meta property="article:modified_time" content="2020-07-16T09:40:32.275Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Shiro简单入门" href="http://x2yu.com/2020/02/05/Shiro%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"><link rel="next" title="JAVA JVM基础复习" href="http://x2yu.com/2019/11/15/JVM%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#胡乱整理的问题集"><span class="toc-number">1.</span> <span class="toc-text">胡乱整理的问题集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String的APi"><span class="toc-number">2.</span> <span class="toc-text">1.String的APi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JAVA链表的实现"><span class="toc-number">3.</span> <span class="toc-text">2. JAVA链表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JAVA8的新特性"><span class="toc-number">4.</span> <span class="toc-text">3.JAVA8的新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring的依赖注入的方式"><span class="toc-number">5.</span> <span class="toc-text">5.Spring的依赖注入的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-requestbody和-responsebody的区别"><span class="toc-number">6.</span> <span class="toc-text">6.@requestbody和@responsebody的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Content-type的常见类型"><span class="toc-number">7.</span> <span class="toc-text">7.Content-type的常见类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-数据库的三大范式"><span class="toc-number">8.</span> <span class="toc-text">8.数据库的三大范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-数据库中时间的类型"><span class="toc-number">9.</span> <span class="toc-text">9.数据库中时间的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-字符串中出现次数最多的字符"><span class="toc-number">10.</span> <span class="toc-text">10.字符串中出现次数最多的字符</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">阿鱼的碎碎念</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">小问题集1</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-12-07 20:37:03"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2019-12-07</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-16 17:40:32"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-16</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 19 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="胡乱整理的问题集"><a href="#胡乱整理的问题集" class="headerlink" title="胡乱整理的问题集"></a><center>胡乱整理的问题集</center></h3><p>到处都是问题，查漏补缺<a id="more"></a></p>
<h3 id="1-String的APi"><a href="#1-String的APi" class="headerlink" title="1.String的APi"></a>1.String的APi</h3><p>String类属于引用数据类型,且不能被继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>获取类的方法</strong></li>
</ol>
<p>length()获取类的长度</p>
<p><code>int i = s.length()</code></p>
<p>获取指定位置的字符</p>
<p><code>char ch = s.charAt(0)</code></p>
<p>返回”ch”在字符串中第一次出现的的位置。四种重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = s.indexOf(<span class="string">"T"</span>);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>int lastIndexOf(参数)方法也有四种重载，找ch最后一次出现的位置。</p>
<ol start="2">
<li><strong>判断类的方法</strong></li>
</ol>
<p>boolean contains(CharSequence s)：当且仅当包含指定的char值序列（字符串）时，返回true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean b &#x3D; s.contains(&quot;T&quot;);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>boolean isEmpty()：字符中是否为空，当且仅当length()为0是返回true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean b1 &#x3D; s.isEmpty();</span><br></pre></td></tr></table></figure>

<p>boolean startsWith(String str)：字符串是否是以指定内容开头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean b2 &#x3D; s.startsWith(&quot;S&quot;);&#x2F;&#x2F;fasle</span><br></pre></td></tr></table></figure>

<p>boolean endsWith(String str)：字符串是否是以指定内容结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean b3 &#x3D; s.startsWith(&quot;T&quot;);</span><br></pre></td></tr></table></figure>

<p>boolean equals(Object obj)：判断此字符串是否与一个对象相等。<strong>重写了Object类中的equals()方法。</strong></p>
<p><code>重写为内容比较</code></p>
<p>boolean equalsIgnoreCase(String anotherString)：判断此String是否与另一个String相同，并忽略大小写。</p>
<ol start="3">
<li><strong>转换类方法</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char [] sch  &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;</span><br></pre></td></tr></table></figure>

<p>String(char [] chars) 将字符数组转换成字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s2 &#x3D; new String(sch);</span><br></pre></td></tr></table></figure>

<p>String(char [] value,int offset,int count)  将字符数组中的一部分转换成字符串。第一个参数是char类型的数组，第二个参数为第一个字符的索引（注意：从0开始计数），第三个参数表示长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s3 &#x3D; new String(sch,1,2);&#x2F;&#x2F;截取为bc</span><br><span class="line">String s4 &#x3D; new String(sch,2,1);&#x2F;&#x2F;截取为c</span><br></pre></td></tr></table></figure>

<p>static String copyValueOf(char [] data)  返回指定数组中表示该字符序列的 String。<br><code>实质是调用了无参的构造方法，底层都调用的this.value = Arrays.copyOf(value, value.length);</code></p>
<p>static String copyValueOf(char [] data,int offset , int count) 返回指定数组中表示该字符序列的 String。</p>
<p><code>同样是调用了有参的构造方法，底层调用Arrays.copyOfRange(value, offset, offset+count);</code></p>
<p>char [] toCharArray() 将字符串转换成字符数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char [] ch1 &#x3D; s.toCharArray();</span><br></pre></td></tr></table></figure>

<p>使用平台的默认字符集将此 String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte[] bt &#x3D; s.getBytes();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>替换类方法</strong></li>
</ol>
<p>String replace(char oldChar,char newChar); 返回一个新的字符串，它是通过用 newChar替换此字符串中出现的所有 oldChar得到的。如果要替换的字符不存在，则返回的还是原串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String st &#x3D; s.replace(&quot;T&quot;,&quot;t&quot;);&#x2F;&#x2F;tESt</span><br></pre></td></tr></table></figure>

<p>public String replaceAll(String regex,String replacement)使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的每个子字符串。</p>
<ol start="5">
<li><strong>切割方法</strong></li>
</ol>
<p>String [] split(String regex); 根据给定正则表达式拆分此字符串，将拆分的字符串按次序放入一个String数组返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String spr &#x3D; &quot;A1B2C3D4&quot;;</span><br><span class="line">String[] chsp &#x3D; spr.split(&quot;\\d+&quot;);&#x2F;&#x2F;数字拆分&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>子串方法</strong></li>
</ol>
<p>String substring(int beginIndex); 返回一个新的字符串，它是此字符串的一个子字符串，从指定的位置开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String st2 &#x3D; s.substring(1);&#x2F;&#x2F;EST</span><br></pre></td></tr></table></figure>

<p>String substring(int beginIndex,int endIndex);  获取字符串中的一部分。从指定的位置开始，到指定的位置前一位结束。</p>
<ol start="7">
<li><strong>其他方法</strong></li>
</ol>
<p>String toUpperCase()：使用默认语言环境的规则将此 String中的所有字符都转换为大写。<br>String toLowerCase()： 使用默认语言环境的规则将此 String中的所有字符都转换为小写。<br>String trim()：返回字符串的副本，忽略前导空白和尾部空白，即将字符串两端的多个空格去除。<br>int compareTo(String )对两个字符串进行自然顺序的比较。此方法多用于集合框架中。</p>
<h3 id="2-JAVA链表的实现"><a href="#2-JAVA链表的实现" class="headerlink" title="2. JAVA链表的实现"></a>2. JAVA链表的实现</h3><p>先看结构图，链表的实现类</p>
<p><img src= "/img/loading.gif" data-src="/assets/blogImg/image-20191202154956412.png" alt="image-20191202154956412"></p>
<ol>
<li><p><strong>ArrayList的实现，底层为数组队列，相当于动态数组。</strong></p>
<p>继承类以及实现的接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了<strong>RandomAccess 接口</strong>， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p>
<p>　　ArrayList 实现了<strong>Cloneable 接口</strong>，即覆盖了函数 clone()，<strong>能被克隆</strong>。</p>
<p>　　ArrayList 实现<strong>java.io.Serializable 接口</strong>，这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p>
<p>　　和 Vector 不同，<strong>ArrayList 中的操作不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector(不用) 或者 <strong>CopyOnWriteArrayList</strong>。</p>
</li>
</ol>
<p>   <strong>静态变量</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//初始化默认大小10</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//空数组 用于空实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认大小空实例数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//保存ArrayList数据的数组</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//数组元素个数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>   <strong>构造方法</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造方法 用户自定义大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造方法 10大小的空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用空数组替换</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<ol start="2">
<li>LinkedList</li>
</ol>
<p>继承类以及实现的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>LinkedList是一个实现了List接口和Deque接口的<strong>双端链表</strong>。</p>
<p> LinkedList底层的链表结构使它<strong>支持高效的插入和删除操作</strong>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性。</p>
<p>LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的<strong>synchronizedList方法。</strong></p>
<p><strong>内部结构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;&#x2F;&#x2F;节点值</span><br><span class="line">    Node&lt;E&gt; next;&#x2F;&#x2F;前驱节点</span><br><span class="line">    Node&lt;E&gt; prev;&#x2F;&#x2F;后继节点</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;空构造方法</span><br><span class="line">   public LinkedList() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;用已有的集合创建链表的构造方法</span><br><span class="line">   public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       this();</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>add方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将元素添加到链表尾</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>add(int index,E e)：在指定位置添加元素</strong></p>
<pre><code>public void add(int index, E element) {
    checkPositionIndex(index);//检查索引是否处于[0-size]之间

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

void linkLast(E e) {
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;//添加在链表尾部
    else
        l.next = newNode;////添加在链表中间
    size++;
    modCount++;
}

void linkBefore(E e, Node&lt;E&gt; succ) {
    //指定坐标节点不为空
    final Node&lt;E&gt; pred = succ.prev;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}</code></pre><p><strong>addAll(Collection c )：将集合插入到链表尾部</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);&#x2F;&#x2F;size为尾部节点坐标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a &#x3D; c.toArray();&#x2F;&#x2F;把集合的数据存到对象数组中</span><br><span class="line">    int numNew &#x3D; a.length;</span><br><span class="line">    if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;&#x2F;&#x2F;得到插入位置的前驱节点和后继节点</span><br><span class="line">    if (index &#x3D;&#x3D; size) &#123;&#x2F;&#x2F;如果插入位置为尾部，前驱节点为last，后继节点为null</span><br><span class="line">        succ &#x3D; null;</span><br><span class="line">        pred &#x3D; last;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;否则，调用node()方法得到后继节点，再得到前驱节点 </span><br><span class="line">        succ &#x3D; node(index);</span><br><span class="line">        pred &#x3D; succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred &#x3D;&#x3D; null)&#x2F;&#x2F;如果插入位置在链表头部</span><br><span class="line">            first &#x3D; newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; newNode;</span><br><span class="line">        pred &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (succ &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;&#x2F;&#x2F;如果插入位置在尾部，重置last节点</span><br><span class="line">        last &#x3D; pred;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;否则，将插入的链表与先前链表连接起来</span><br><span class="line">        pred.next &#x3D; succ;</span><br><span class="line">        succ.prev &#x3D; pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);&#x2F;&#x2F;新建节点，以头节点为后继节点</span><br><span class="line">    first &#x3D; newNode;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>get(int index)：</strong> 根据指定索引返回数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);&#x2F;&#x2F;&#x2F;&#x2F;检查index范围是否在size之内</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取头节点（index=0）数据方法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong> getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>
<p><strong>获取尾节点（index=-1）数据方法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E peekLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    return (l &#x3D;&#x3D; null) ? null : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>根据对象获取索引</strong></p>
<p><strong>int indexOf(Object o)：</strong> 从头遍历找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null)</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item))</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">        int index &#x3D; size;</span><br><span class="line">        if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;从尾遍历</span><br><span class="line">            for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                if (x.item &#x3D;&#x3D; null)</span><br><span class="line">                    return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;从尾遍历</span><br><span class="line">            for (Node&lt;E&gt; x &#x3D; last; x !&#x3D; null; x &#x3D; x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                if (o.equals(x.item))</span><br><span class="line">                    return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) !&#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>删除方法</strong></p>
<p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E remove() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pop() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>removeLast(),pollLast():</strong> 删除尾节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    return (l &#x3D;&#x3D; null) ? null : unlinkLast(l);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>remove(int index)</strong>：删除指定位置的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public E remove(int index) &#123;</span><br><span class="line">      checkElementIndex(index);</span><br><span class="line">      return unlink(node(index));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">      &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">      final E element &#x3D; x.item;</span><br><span class="line">      final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">      final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line"></span><br><span class="line">      if (prev &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果删除的节点是头节点,令头节点指向该节点的后继节点</span><br><span class="line">          first &#x3D; next;</span><br><span class="line">      &#125; else &#123;&#x2F;&#x2F;将前驱节点的后继节点指向后继节点</span><br><span class="line">          prev.next &#x3D; next;</span><br><span class="line">          x.prev &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除后继指针</span><br><span class="line">      if (next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span><br><span class="line">          last &#x3D; prev;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          next.prev &#x3D; prev;</span><br><span class="line">          x.next &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      x.item &#x3D; null;</span><br><span class="line">      size--;</span><br><span class="line">      modCount++;</span><br><span class="line">      return element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-JAVA8的新特性"><a href="#3-JAVA8的新特性" class="headerlink" title="3.JAVA8的新特性"></a>3.JAVA8的新特性</h3><p>编辑中</p>
<blockquote>
<p><a href="https://www.cnblogs.com/WJ5888/p/4667086.html" target="_blank" rel="noopener">Java 8 Lambda实现原理分析</a></p>
</blockquote>
<h3 id="5-Spring的依赖注入的方式"><a href="#5-Spring的依赖注入的方式" class="headerlink" title="5.Spring的依赖注入的方式"></a>5.Spring的依赖注入的方式</h3><blockquote>
<p> <a href="https://blog.csdn.net/a909301740/article/details/78379720" target="_blank" rel="noopener">Spring的常用三种注解方式</a>.</p>
</blockquote>
<p><strong>1.构造器注入</strong></p>
<p><strong>2.setter注入</strong></p>
<p><strong>3.基于注解的注入</strong></p>
<h3 id="6-requestbody和-responsebody的区别"><a href="#6-requestbody和-responsebody的区别" class="headerlink" title="6.@requestbody和@responsebody的区别"></a>6.@requestbody和@responsebody的区别</h3><p>@requestbody：将<strong>前台</strong>的key，value数据data：name=“1”&amp;id=1 </p>
<p>或者json数据data ：{name：“1”，id：1 } 转换成<strong>java对象</strong>入形参。</p>
<p>@responsebody：将<strong>返回到前台的java对象转换成json串</strong>输出。</p>
<h3 id="7-Content-type的常见类型"><a href="#7-Content-type的常见类型" class="headerlink" title="7.Content-type的常见类型"></a>7.Content-type的常见类型</h3><p><strong>1、application/x-www-form-urlencoded</strong></p>
<p>1）浏览器的原生form表单<br>2） 提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key和val都进行了URL转码</p>
<p><strong>2.multipart/form-data</strong></p>
<p>常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctype 等于这个值。</p>
<p><strong>3.pplication/json</strong></p>
<p>消息主体是序列化后的 JSON 字符串。</p>
<p><strong>4.text/xml</strong></p>
<p>是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范</p>
<h3 id="8-数据库的三大范式"><a href="#8-数据库的三大范式" class="headerlink" title="8.数据库的三大范式"></a>8.数据库的三大范式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF</span><br></pre></td></tr></table></figure>

<p>如果数据库表中的<strong>所有字段值都是不可分解的原子值</strong>，就说明该数据库满足第一范式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。</span><br></pre></td></tr></table></figure>

<p><strong>第二范式需要确保数据库表中每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</strong>。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.</span><br></pre></td></tr></table></figure>

<p>第三范式需要确保数据表中的<strong>每一列数据都和主键直接相关，而不能间接相关。</strong></p>
<h3 id="9-数据库中时间的类型"><a href="#9-数据库中时间的类型" class="headerlink" title="9.数据库中时间的类型"></a>9.数据库中时间的类型</h3><p>Mysql中经常用来存储日期的数据类型有三种：<strong>Date、Datetime、Timestamp</strong>。</p>
<p>1.Date数据类型：用来存储没有时间的日期。Mysql获取和显示这个类型的格式为“YYYY-MM-DD”。支持的时间范围为“1000-00-00”到“9999-12-31”。</p>
<p>2.Datetime类型：存储既有日期又有时间的数据。存储和显示的格式为 “YYYY-MM-DD HH:MM:SS”。支持的时间范围是“1000-00-00 00:00:00”到“9999-12-31 23:59:59”。</p>
<p>3.Timestamp类型：也是存储既有日期又有时间的数据。存储和显示的格式跟Datetime一样。支持的时间范围是“1970-01-01 00:00:01”到“2038-01-19 03:14:07”。</p>
<h3 id="10-字符串中出现次数最多的字符"><a href="#10-字符串中出现次数最多的字符" class="headerlink" title="10.字符串中出现次数最多的字符"></a>10.字符串中出现次数最多的字符</h3><p>思路：<br>  1.通过 char[] toCharArray() 将字符串保存到字符数组中<br>  2.遍历字符数组<br>  3.将数组里的每一个不重复的字符作为键保存到map中，将每一个相同字符的数量作为值保存到map中<br>  4.求出出现次数最多的键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//寻找出现次数最多的字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMaxTimeChar</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map  = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;chars.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            if(map.containsKey(chars[i]))&#123;</span></span><br><span class="line"><span class="comment">//                map.put(chars[i],map.get(chars[i])+1);</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                map.put(chars[i],1);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">                map.put(ch,map.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出现字符次数最多的键值对</span></span><br><span class="line">        Collection values = map.values();</span><br><span class="line">         <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">         max = (Integer) Collections.max(values);</span><br><span class="line"></span><br><span class="line">         Set entrySet = map.entrySet();</span><br><span class="line">         <span class="keyword">for</span>(Object obj:entrySet)&#123;</span><br><span class="line">             Map.Entry entry = (Map.Entry)obj;</span><br><span class="line">             <span class="keyword">if</span>((Integer) entry.getValue()==max)&#123;</span><br><span class="line">                 System.out.println(<span class="string">"出现次数最多的字符为"</span>+entry.getKey()+<span class="string">"次数为"</span>+entry.getValue());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<p>两种情况，有多个相同次数的字符和单个字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaxTimeChar maxTimeChar = <span class="keyword">new</span> MaxTimeChar();</span><br><span class="line">        String str = <span class="string">"asdfsfsaassss"</span>;</span><br><span class="line">        maxTimeChar.findMaxTimeChar(str);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="string">"abcabcab"</span>;</span><br><span class="line">        maxTimeChar.findMaxTimeChar(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line">	&#123;a=<span class="number">3</span>, s=<span class="number">7</span>, d=<span class="number">1</span>, f=<span class="number">2</span>&#125;</span><br><span class="line">	出现次数最多的字符为s次数为<span class="number">7</span></span><br><span class="line">	&#123;a=<span class="number">3</span>, b=<span class="number">3</span>, c=<span class="number">2</span>&#125;</span><br><span class="line">	出现次数最多的字符为a次数为<span class="number">3</span></span><br><span class="line">	出现次数最多的字符为b次数为<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>补</p>
<blockquote>
<p>keySet是键的集合，Set里面的类型即key的类型<br>entrySet是 键-值 对的集合，Set里面的类型是Map.Entry</p>
</blockquote>
<p>java8中Map的使用entry的迭代方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + <span class="string">" "</span> + entry.getValue()));</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">鱼歌唱晚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://x2yu.com/2019/12/07/%E5%B0%8F%E9%97%AE%E9%A2%98%E9%9B%861/">http://x2yu.com/2019/12/07/%E5%B0%8F%E9%97%AE%E9%A2%98%E9%9B%861/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://x2yu.com" target="_blank">阿鱼的碎碎念</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E9%97%AE%E9%A2%98%E9%9B%86/">问题集</a></div><div class="post_share"><div class="social-share" data-image="/assets/cover/mysql_random.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/05/Shiro%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Shiro简单入门</div></div></a></div><div class="next-post pull-right"><a href="/2019/11/15/JVM%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA JVM基础复习</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/04/21/Java程序员-数据结构与算法续篇/" title="Java程序员-数据结构与算法续篇"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-21</div><div class="relatedPosts_title">Java程序员-数据结构与算法续篇</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/15/JVM问题总结/" title="JAVA JVM基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-15</div><div class="relatedPosts_title">JAVA JVM基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/10/29/正则表达式/" title="正则表达式"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-29</div><div class="relatedPosts_title">正则表达式</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/06/Java-List去重问题/" title="Java - List去重问题"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-06</div><div class="relatedPosts_title">Java - List去重问题</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/13/JUC问题总结/" title="JAVA JUC基础复习"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-13</div><div class="relatedPosts_title">JAVA JUC基础复习</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/10/数据库练习题/" title="数据库练习题"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-10</div><div class="relatedPosts_title">数据库练习题</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'yYMa3RDNdOAWjpBmszEXyu3y-gzGzoHsz',
  appKey: '4gdOiHj0hxa5OGKFUHxhKad2',
  placeholder: '随心所欲，畅所欲言(´▽`ʃ♡ƪ)',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 鱼歌唱晚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>